<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guild Hub 1.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
        }

        body {
            font-family: 'Times New Roman', serif;
            background: linear-gradient(90deg, #051A0F 0%, #021207 100%);
            min-height: 100vh;
            margin: 0;
            padding: 0;
            color: #e0e0e0;
        }

        /* Hide ALL scrollbars globally */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* Internet Explorer 10+ */
        }

        *::-webkit-scrollbar {
            display: none; /* WebKit browsers */
        }

        /* Spell Library Styles - copied from monster browser */
        .spell-browser-section {
            margin: 0 0 15px 0;
            padding: 20px;
            background: rgba(4, 14, 8, 0.8);
            border-radius: 8px;
            margin-top: -80px;
            z-index: 100;
        }

        .spell-browser-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 20px;
        }

        .spell-browser-header h3 {
            color: #9d4edd;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2pt;
            margin: 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .spell-browser-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .spell-search-input {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #e0e0e0;
            border: 2px solid #8b7355;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.9rem;
            font-family: 'Times New Roman', serif;
            min-width: 200px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .spell-search-input:focus {
            outline: none;
            border-color: #9d4edd;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 0 2px rgba(157, 78, 221, 0.3);
        }

        .spell-level-filter, .spell-school-filter {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #e0e0e0;
            border: 2px solid #8b7355;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.9rem;
            font-family: 'Times New Roman', serif;
            cursor: pointer;
        }



        .spell-browser-container {
            position: relative;
            overflow: hidden;
            border-radius: 8px;
        }

        .spell-browser-container::before,
        .spell-browser-container::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 120px;
            z-index: 10;
            pointer-events: none;
        }

        .spell-browser-container::before {
            left: 0;
            background: linear-gradient(to right, 
                rgba(4, 14, 8, 1) 0%, 
                rgba(4, 14, 8, 0.9) 20%, 
                rgba(4, 14, 8, 0.6) 50%, 
                rgba(4, 14, 8, 0) 100%);
        }

        .spell-browser-container::after {
            right: 0;
            background: linear-gradient(to left, 
                rgba(4, 14, 8, 1) 0%, 
                rgba(4, 14, 8, 0.9) 20%, 
                rgba(4, 14, 8, 0.6) 50%, 
                rgba(4, 14, 8, 0) 100%);
        }

        .spell-browser-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: #8b7355 rgba(139, 115, 85, 0.2);
            scroll-behavior: smooth;
            padding: 15px 0;
        }

        .spell-browser-content {
            display: flex;
            gap: 12px;
            min-width: min-content;
            padding: 0;
        }

        .spell-library-card {
            background: linear-gradient(180deg, #2a2a3a 0%, #1a1a2a 100%);
            border-radius: 8px;
            min-width: 200px;
            max-width: 200px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 4px 8px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }

        .spell-library-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 12px 40px rgba(157, 78, 221, 0.6);
        }

        .spell-library-content {
            padding: 12px;
            text-align: center;
        }

        .spell-library-name {
            color: #9d4edd;
            font-size: 0.95rem;
            font-weight: bold;
            margin-bottom: 8px;
            line-height: 1.2;
            height: 2.4em;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .spell-library-level {
            color: #ffd700;
            font-size: 0.75rem;
            margin-bottom: 6px;
        }

        .spell-library-school {
            color: #e0e0e0;
            font-size: 0.7rem;
            margin-bottom: 8px;
            text-transform: capitalize;
        }

        .spell-library-description {
            color: #c0c0c0;
            font-size: 0.7rem;
            line-height: 1.3;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 12px;
        }

        .spell-library-image-section {
            width: 100%;
            height: 150px;
            position: relative;
            overflow: hidden;
        }

        .spell-library-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: all 0.3s ease;
        }

        .spell-library-image-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.7) 100%);
        }

        .spell-library-add-btn {
            background: linear-gradient(180deg, #9d4edd 0%, #7b2cbf 100%);
            color: #ffffff;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.75rem;
            font-family: 'Times New Roman', serif;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .spell-library-add-btn:hover {
            background: linear-gradient(180deg, #b968f0 0%, #9d4edd 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .spell-library-add-btn:active {
            transform: translateY(0);
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.4),
                0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Animation for newly added spell cards */
        @keyframes spellCardAdded {
            0% {
                transform: translateX(-200px) rotate(-8deg) scale(0.9);
                opacity: 0;
                box-shadow: 
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 12px 24px rgba(0, 0, 0, 0.6);
            }
            60% {
                opacity: 1;
                transform: translateX(8px) rotate(1deg) scale(1.01);
                box-shadow: 
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 8px 16px rgba(0, 0, 0, 0.5);
            }
            100% {
                transform: translateX(0) rotate(0deg) scale(1);
                opacity: 1;
                box-shadow: 
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 6px 12px rgba(0, 0, 0, 0.4);
            }
        }

        .spell-card-new {
            animation: spellCardAdded 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        /* Deck open state - no longer needed as we cover the scrollbar */

        .app {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 10px;
            width: 100%;
            max-width: 100vw;
            box-sizing: border-box;
        }

        .app-header {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 1px solid #8b7355;
            border-radius: 6px;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.4);
            margin-bottom: 4px;
            position: fixed;
            top: 10px;
            left: 10px;
            right: 10px;
            z-index: 1000;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .app-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.05) 50%, transparent 70%);
            pointer-events: none;
        }

        .app-header h1 {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 
                1px 1px 2px rgba(0, 0, 0, 0.8),
                0 0 6px rgba(255, 215, 0, 0.3);
            font-family: 'Times New Roman', serif;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .guild-selector {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #ffd700;
            border: 2px solid #8b7355;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 0.8rem;
            font-weight: bold;
            font-family: 'Times New Roman', serif;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .guild-selector:hover {
            background: linear-gradient(180deg, #5a5a5a 0%, #4a4a4a 100%);
            border-color: #a0522d;
        }

        .guild-selector:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4),
                0 0 0 2px rgba(255, 215, 0, 0.3);
        }

        /* Guild Login Screen */
        .guild-login-screen {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0A0502 0%, #1A0F0A 50%, #0A0502 100%);
        }

        .guild-login-form {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 2px solid #8b7355;
            border-radius: 8px;
            padding: 25px;
            width: 100%;
            max-width: 300px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 6px 12px rgba(0, 0, 0, 0.6);
        }

        .guild-login-form h2 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.3rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            color: #ffd700;
            margin-bottom: 8px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input {
            width: 100%;
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            border: 2px solid #8b7355;
            border-radius: 6px;
            padding: 10px;
            color: #e0e0e0;
            font-family: 'Times New Roman', serif;
            font-size: 0.9rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .form-group input:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 0 2px rgba(255, 215, 0, 0.3);
        }

        .login-btn {
            width: 100%;
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3a 100%);
            color: #ffd700;
            border: 2px solid #a0522d;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: normal;
            font-family: 'Times New Roman', serif;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
            text-transform: none;
            letter-spacing: 0.5px;
        }

        .login-btn:hover {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            transform: translateY(-1px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .current-guild-info {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #ffd700;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: bold;
            border: 1px solid #8b7355;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .campaign-selector-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .campaign-selector {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #ffd700;
            border: 2px solid #8b7355;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.8rem;
            font-weight: normal;
            font-family: 'Times New Roman', serif;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.4);
            min-width: 150px;
        }

        .campaign-selector:hover {
            background: linear-gradient(180deg, #5a5a5a 0%, #4a4a4a 100%);
            border-color: #a0522d;
        }

        .campaign-selector:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4),
                0 0 0 2px rgba(255, 215, 0, 0.3);
        }

        .new-campaign-btn {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3a 100%);
            color: #ffd700;
            border: 2px solid #a0522d;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.8rem;
            font-weight: normal;
            font-family: 'Times New Roman', serif;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
            text-transform: none;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .new-campaign-btn:hover {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            transform: translateY(-1px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        /* Campaign Modal */
        .campaign-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        }

        .campaign-modal-content {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 2px solid #8b7355;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .campaign-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 2px solid #8b7355;
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            border-radius: 10px 10px 0 0;
        }

        .campaign-modal-header h3 {
            color: #ffd700;
            font-size: 1.4rem;
            font-weight: bold;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .campaign-modal-body {
            padding: 20px;
        }

        .campaign-modal-body .form-group {
            margin-bottom: 20px;
        }

        .campaign-modal-body .form-group label {
            display: block;
            color: #ffd700;
            margin-bottom: 8px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .campaign-modal-body .form-group input,
        .campaign-modal-body .form-group textarea {
            width: 100%;
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            border: 2px solid #8b7355;
            border-radius: 6px;
            padding: 12px;
            color: #e0e0e0;
            font-family: 'Times New Roman', serif;
            font-size: 1rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .campaign-modal-body .form-group textarea {
            min-height: 80px;
            resize: vertical;
        }

        .campaign-modal-body .form-group input:focus,
        .campaign-modal-body .form-group textarea:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 0 2px rgba(255, 215, 0, 0.3);
        }

        .campaign-modal-actions {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            margin-top: 30px;
        }

        .cancel-btn {
            background: linear-gradient(180deg, #6b7280 0%, #4b5563 100%);
            color: #ffffff;
            border: 2px solid #374151;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .cancel-btn:hover {
            background: linear-gradient(180deg, #4b5563 0%, #374151 100%);
            transform: translateY(-1px);
        }

        .create-campaign-btn {
            background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%);
            color: #ffffff;
            border: 2px solid #15803d;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .create-campaign-btn:hover {
            background: linear-gradient(180deg, #16a34a 0%, #15803d 100%);
            transform: translateY(-1px);
        }

        /* Our Story Section */
        .our-story-section {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 1px solid #8b7355;
            border-radius: 8px;
            margin: 20px 40px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .our-story-header {
            padding: 12px 18px;
            border-bottom: 1px solid #8b7355;
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            border-radius: 7px 7px 0 0;
        }

        .our-story-header h2 {
            color: #ffd700;
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .our-story-content {
            display: flex;
            gap: 15px;
            padding: 15px;
        }

        .story-text-area {
            flex: 2;
        }

        .story-text-area textarea {
            width: 100%;
            min-height: 120px;
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            border: 1px solid #8b7355;
            border-radius: 6px;
            padding: 12px;
            color: #e0e0e0;
            font-family: 'Times New Roman', serif;
            font-size: 0.85rem;
            line-height: 1.5;
            resize: vertical;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .story-text-area textarea:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 0 2px rgba(255, 215, 0, 0.3);
        }

        .story-image-placeholder {
            flex: 1;
            min-width: 200px;
        }

        .image-placeholder {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            border: 1px dashed #8b7355;
            border-radius: 6px;
            height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #b0b0b0;
            font-family: 'Times New Roman', serif;
            padding: 12px;
        }

        .image-placeholder span {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        .image-placeholder p {
            font-size: 0.8rem;
            margin: 0;
            text-align: center;
        }

        /* Character Section */
        .character-section {
            margin-top: 30px;
        }

        .character-section-header {
            margin-bottom: 5px;
            text-align: center;
        }

        .character-section-header h2 {
            color: #ffd700;
            font-size: 12px;
            font-weight: normal;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        /* Campaign Banner */
        .campaign-banner-section {
            margin-bottom: 30px;
        }

        .campaign-banner {
            position: relative;
            height: 200px;
            border-radius: 12px;
            overflow: hidden;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 2px solid #8b7355;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .campaign-banner.has-image {
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .campaign-banner-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                135deg,
                rgba(0, 0, 0, 0.7) 0%,
                rgba(0, 0, 0, 0.4) 50%,
                rgba(0, 0, 0, 0.7) 100%
            );
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .campaign-banner-title {
            color: #ffd700;
            font-size: 2.5rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 
                3px 3px 6px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(255, 215, 0, 0.4);
            margin: 0;
            text-align: center;
        }

        .campaign-banner-actions {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 3;
            display: flex;
            gap: 10px;
        }

        .generate-banner-btn,
        .regenerate-banner-btn {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3a 100%);
            color: #ffd700;
            border: 2px solid #a0522d;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .generate-banner-btn:hover,
        .regenerate-banner-btn:hover {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            transform: translateY(-1px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .generate-banner-btn.loading {
            background: linear-gradient(180deg, #6b7280 0%, #4b5563 100%);
            color: #ffffff;
            cursor: not-allowed;
        }

        .generate-banner-btn.loading:hover {
            transform: none;
        }

        /* Dice Roller Button */
        .dice-roller-btn {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3a 100%);
            color: #ffd700;
            border: 1px solid #a0522d;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Times New Roman', serif;
            min-width: 120px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dice-roller-btn:hover {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            transform: translateY(-1px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        /* Small Dice Roller Popup */
        .dice-roller-popup {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
        }

        .dice-roller-popup-content {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 1px solid #8b7355;
            border-radius: 8px;
            padding: 0;
            width: 400px;
            max-height: 500px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .dice-roller-popup-header {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border-bottom: 1px solid #8b7355;
            padding: 10px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 7px 7px 0 0;
        }

        .dice-roller-popup-header h3 {
            color: #ffd700;
            font-size: 1rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0;
            font-family: 'Times New Roman', serif;
        }

        .close-dice-popup-btn {
            background: linear-gradient(180deg, #6b5b3a 0%, #4a4a4a 100%);
            color: #ffd700;
            border: 1px solid #8b7355;
            border-radius: 3px;
            width: 20px;
            height: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Times New Roman', serif;
        }

        .close-dice-popup-btn:hover {
            background: linear-gradient(180deg, #a0522d 0%, #6b5b3a 100%);
            transform: scale(1.1);
        }

        .dice-roller-popup-body {
            padding: 12px;
        }

        .dice-selection-popup {
            margin-bottom: 12px;
        }

        .dice-type-selector-popup {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 10px;
        }

        .dice-type-btn-popup {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #ffd700;
            border: 1px solid #8b7355;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Times New Roman', serif;
        }

        .dice-type-btn-popup:hover {
            background: linear-gradient(180deg, #5a5a5a 0%, #4a4a4a 100%);
            border-color: #a0522d;
        }

        .dice-type-btn-popup.active {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            border-color: #ffd700;
            box-shadow: 0 0 6px rgba(255, 215, 0, 0.3);
        }

        .dice-controls-popup {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .control-group label {
            color: #ffd700;
            font-weight: bold;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Times New Roman', serif;
        }

        .quantity-controls-popup,
        .modifier-controls-popup {
            display: flex;
            align-items: center;
            gap: 3px;
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 1px solid #8b7355;
            border-radius: 3px;
            padding: 2px 4px;
        }

        .quantity-controls-popup span,
        .modifier-controls-popup span {
            color: #ffd700;
            font-weight: bold;
            font-size: 0.8rem;
            min-width: 20px;
            text-align: center;
            font-family: 'Times New Roman', serif;
        }

        .control-btn-popup {
            background: linear-gradient(180deg, #6b5b3a 0%, #4a4a4a 100%);
            color: #ffd700;
            border: 1px solid #8b7355;
            border-radius: 2px;
            width: 18px;
            height: 18px;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Times New Roman', serif;
        }

        .control-btn-popup:hover {
            background: linear-gradient(180deg, #a0522d 0%, #6b5b3a 100%);
            transform: scale(1.1);
        }

        .dice-tray-popup {
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 1px solid #8b7355;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            min-height: 70px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .dice-container-popup {
            display: flex;
            gap: 6px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            min-height: 35px;
        }

        .dice-popup {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 50%, #45b7d1 100%);
            border: 1px solid #333;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            color: #fff;
            font-family: 'Times New Roman', serif;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.4),
                0 0 8px rgba(255, 107, 107, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        /* Dice shapes based on type */
        .dice-popup.d4 {
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 50%, #ff3838 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.4),
                0 0 8px rgba(255, 107, 107, 0.4);
        }

        .dice-popup.d6 {
            border-radius: 3px;
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 50%, #2c3e50 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.4),
                0 0 8px rgba(78, 205, 196, 0.4);
        }

        .dice-popup.d8 {
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: linear-gradient(135deg, #45b7d1 0%, #3498db 50%, #2980b9 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.4),
                0 0 8px rgba(69, 183, 209, 0.4);
        }

        .dice-popup.d10 {
            clip-path: polygon(50% 0%, 100% 20%, 100% 80%, 50% 100%, 0% 80%, 0% 20%);
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 50%, #d35400 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.4),
                0 0 8px rgba(243, 156, 18, 0.4);
        }

        .dice-popup.d12 {
            clip-path: polygon(50% 0%, 100% 15%, 100% 85%, 50% 100%, 0% 85%, 0% 15%);
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 50%, #7d3c98 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.4),
                0 0 8px rgba(155, 89, 182, 0.4);
        }

        .dice-popup.d20 {
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 50%, #a93226 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.4),
                0 0 8px rgba(231, 76, 60, 0.4);
        }

        .dice-popup.d100 {
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 50%, #229954 100%);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 2px 6px rgba(0, 0, 0, 0.4),
                0 0 8px rgba(46, 204, 113, 0.4);
        }

        .dice-popup.rolling {
            animation: diceRollPopup 0.8s ease-in-out;
        }

        @keyframes diceRollPopup {
            0% { 
                transform: rotate(0deg) scale(1) translateY(0px);
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            }
            15% { 
                transform: rotate(45deg) scale(1.2) translateY(-8px);
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.6);
            }
            30% { 
                transform: rotate(90deg) scale(0.8) translateY(4px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            }
            45% { 
                transform: rotate(180deg) scale(1.3) translateY(-12px);
                box-shadow: 0 12px 24px rgba(0, 0, 0, 0.7);
            }
            60% { 
                transform: rotate(270deg) scale(0.7) translateY(6px);
                box-shadow: 0 6px 12px rgba(0, 0, 0, 0.6);
            }
            75% { 
                transform: rotate(315deg) scale(1.1) translateY(-4px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            }
            100% { 
                transform: rotate(360deg) scale(1) translateY(0px);
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
            }
        }

        .roll-dice-btn-popup {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            color: #ffd700;
            border: 1px solid #ffd700;
            border-radius: 4px;
            padding: 6px 16px;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Times New Roman', serif;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 1px 3px rgba(0, 0, 0, 0.4);
        }

        .roll-dice-btn-popup:hover {
            background: linear-gradient(180deg, #ffd700 0%, #a0522d 100%);
            color: #333;
            transform: translateY(-1px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .roll-dice-btn-popup:disabled {
            background: linear-gradient(180deg, #6b7280 0%, #4b5563 100%);
            color: #9ca3af;
            border-color: #6b7280;
            cursor: not-allowed;
            transform: none;
        }

        .roll-result-popup {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 1px solid #8b7355;
            border-radius: 4px;
            padding: 6px 10px;
            text-align: center;
            font-size: 0.8rem;
            color: #ffd700;
            font-weight: bold;
            min-height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Times New Roman', serif;
        }

        .roll-result-popup:empty {
            color: #666;
            font-style: italic;
        }

        .roll-history-popup {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 1px solid #8b7355;
            border-radius: 4px;
            padding: 8px;
            margin-top: 6px;
        }

        .roll-history-popup h4 {
            color: #ffd700;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0 0 6px 0;
            text-align: center;
            font-family: 'Times New Roman', serif;
        }

        .history-list-popup {
            max-height: 100px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .history-item-popup {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 1px solid #8b7355;
            border-radius: 3px;
            padding: 4px 6px;
            font-size: 0.7rem;
            color: #e0e0e0;
            font-family: 'Times New Roman', serif;
        }

        .history-item-popup .roll-result {
            color: #ffd700;
            font-weight: bold;
        }

        /* Message Board Button */
        .message-board-btn {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3a 100%);
            color: #ffd700;
            border: 1px solid #a0522d;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Times New Roman', serif;
            min-width: 120px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message-board-btn:hover {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            transform: translateY(-1px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        /* Message Board Popup */
        .message-board-popup {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .message-board-popup-content {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 1px solid #8b7355;
            border-radius: 8px;
            padding: 0;
            width: 450px;
            height: 400px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }

        .message-board-popup-header {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border-bottom: 1px solid #8b7355;
            padding: 10px 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 7px 7px 0 0;
        }

        .message-board-popup-header h3 {
            color: #ffd700;
            font-size: 1rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0;
            font-family: 'Times New Roman', serif;
        }

        .close-message-board-btn {
            background: linear-gradient(180deg, #6b5b3a 0%, #4a4a4a 100%);
            color: #ffd700;
            border: 1px solid #8b7355;
            border-radius: 3px;
            width: 20px;
            height: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Times New Roman', serif;
        }

        .close-message-board-btn:hover {
            background: linear-gradient(180deg, #a0522d 0%, #6b5b3a 100%);
            transform: scale(1.1);
        }

        .message-board-popup-body {
            padding: 12px;
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 10px;
        }

        .message-input-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .character-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .character-selector label {
            color: #ffd700;
            font-weight: bold;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Times New Roman', serif;
            min-width: 60px;
        }

        .character-select {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            color: #ffd700;
            border: 1px solid #8b7355;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 0.7rem;
            font-family: 'Times New Roman', serif;
            flex: 1;
        }

        .message-input-container {
            display: flex;
            gap: 6px;
        }

        .message-input {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            color: #e0e0e0;
            border: 1px solid #8b7355;
            border-radius: 3px;
            padding: 6px 10px;
            font-size: 0.8rem;
            font-family: 'Times New Roman', serif;
            flex: 1;
        }

        .message-input:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.3);
        }

        .send-message-btn {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            color: #ffd700;
            border: 1px solid #ffd700;
            border-radius: 3px;
            padding: 6px 12px;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Times New Roman', serif;
        }

        .send-message-btn:hover {
            background: linear-gradient(180deg, #ffd700 0%, #a0522d 100%);
            color: #333;
            transform: translateY(-1px);
        }

        .message-display {
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 1px solid #8b7355;
            border-radius: 4px;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }

        .message-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .message-item {
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 1px solid #8b7355;
            border-radius: 3px;
            padding: 6px 8px;
            font-size: 0.7rem;
            color: #e0e0e0;
            font-family: 'Times New Roman', serif;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .message-character {
            color: #ffd700;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .message-time {
            color: #888;
            font-size: 0.6rem;
        }

        .message-content {
            color: #e0e0e0;
            word-wrap: break-word;
        }

        .message-tabs {
            display: flex;
            gap: 4px;
        }

        .message-tab {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #ffd700;
            border: 1px solid #8b7355;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 0.6rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Times New Roman', serif;
            flex: 1;
        }

        .message-tab:hover {
            background: linear-gradient(180deg, #5a5a5a 0%, #4a4a4a 100%);
            border-color: #a0522d;
        }

        .message-tab.active {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            border-color: #ffd700;
            box-shadow: 0 0 4px rgba(255, 215, 0, 0.3);
        }

        .status-message {
            padding: 6px 8px;
            border-radius: 4px;
            margin: 6px 0;
            font-weight: normal;
            font-size: 0.8rem;
        }

        .status-success {
            background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%);
            color: #ffffff;
            border: 1px solid #15803d;
        }

        .status-error {
            background: linear-gradient(180deg, #dc2626 0%, #b91c1c 100%);
            color: #fecaca;
            border: 1px solid #991b1b;
            opacity: 0.9;
        }

        .guild-name-display {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #ffd700;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            border: 2px solid #8b7355;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 2px 4px rgba(0, 0, 0, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .connection-status {
            background: linear-gradient(180deg, #14532d 0%, #15803d 100%);
            color: #ffd700;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: bold;
            border: 1px solid #27ae60;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .connection-status.disconnected {
            background: linear-gradient(180deg, #7f1d1d 0%, #991b1b 100%);
            border-color: #dc2626;
        }

        .add-character-btn {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3a 100%);
            color: #ffd700;
            border: 2px solid #a0522d;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
            font-family: 'Times New Roman', serif;
            text-transform: none;
            letter-spacing: 0.5px;
        }

        .add-character-btn:hover {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            transform: translateY(-1px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .add-character-btn:active {
            transform: translateY(0);
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.4),
                0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .app-main {
            flex: 1;
            padding: 10px;
            padding-top: 60px;
            overflow: auto;
            transform: scale(0.9);
            transform-origin: top center;
            /* Hide scrollbar */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* Internet Explorer 10+ */
        }

        .app-main::-webkit-scrollbar {
            display: none; /* WebKit browsers */
        }

        .character-deck {
            display: grid;
            grid-template-columns: repeat(auto-fit, 320px);
            gap: 18px;
            max-width: 1400px;
            margin: 0 auto 30px auto;
            padding: 30px;
            justify-content: center;
            overflow: visible;
        }

        @media (max-width: 768px) {
            .character-deck {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .character-card {
            background: #17140F;
            border: none;
            border-radius: 8px;
            padding: 18px;
            padding-bottom: 60px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 6px 12px rgba(0, 0, 0, 0.6);
            position: relative;
            transition: all 0.3s ease;
            min-height: 380px;
            max-width: 320px;
            width: 100%;
            display: flex;
            flex-direction: column;
            overflow: visible;
        }

        .character-card.new-card {
            animation: cardDealt 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            transform: translateX(-100vw) rotate(-15deg);
            opacity: 0;
        }

        @keyframes cardDealt {
            0% {
                transform: translateX(-100vw) rotate(-15deg) scale(0.8);
                opacity: 0;
                box-shadow: 
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 20px 40px rgba(0, 0, 0, 0.8);
            }
            30% {
                opacity: 1;
                transform: translateX(-20px) rotate(-8deg) scale(0.95);
                box-shadow: 
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 15px 30px rgba(0, 0, 0, 0.7);
            }
            70% {
                transform: translateX(10px) rotate(2deg) scale(1.02);
                box-shadow: 
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 8px 16px rgba(0, 0, 0, 0.6);
            }
            85% {
                transform: translateX(0) rotate(-1deg) scale(1.01);
                box-shadow: 
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 6px 12px rgba(0, 0, 0, 0.6);
            }
            100% {
                transform: translateX(0) rotate(0deg) scale(1);
                opacity: 1;
                box-shadow: 
                    inset 0 1px 0 rgba(255, 255, 255, 0.1),
                    0 6px 12px rgba(0, 0, 0, 0.6);
            }
        }

        .character-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.03) 50%, transparent 70%);
            pointer-events: none;
            border-radius: 5px;
        }

        .character-card:hover {
            transform: translateY(-3px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                0 8px 16px rgba(0, 0, 0, 0.8);
            border-color: #a0522d;
        }

        /* Card Texture System */
        .card-texture {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            height: 471px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 0;
            opacity: 1;
            transition: all 0.3s ease;
        }

        /* Default texture - bright yellow rounded rectangle */
        .card-texture.default {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            box-shadow: 
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Enemy cards get dark red default texture */
        .character-card.enemy .card-texture.default {
            background: linear-gradient(135deg, #5a2020 0%, #3a1010 100%) !important;
            box-shadow: 
                inset 0 2px 4px rgba(90, 32, 32, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Race-specific textures */
        .card-texture.human {
            background-image: url('textures/human.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .card-texture.elf {
            background-image: url('textures/elf.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .card-texture.dwarf {
            background-image: url('textures/dwarf.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .card-texture.halfling {
            background-image: url('textures/halfling.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .card-texture.dragonborn {
            background-image: url('textures/dragonborn.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .card-texture.tiefling {
            background-image: url('textures/tiefling.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .card-texture.half-orc {
            background-image: url('textures/halforc.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .card-texture.gnome {
            background-image: url('textures/gnome.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .card-texture.half-elf {
            background-image: url('textures/halfelf.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .card-texture.aarakocra {
            background: linear-gradient(135deg, #F0F8FF 0%, #B0C4DE 100%);
        }

        .card-header {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-bottom: 0;
            position: relative;
            z-index: 1;
        }

        /* Race-specific header element backgrounds - Target only hex stat input (2nd), not HP shield (1st) */
        .character-card.race-human .header-top-section,
        .character-card.race-human .header-bottom-section,
        .character-card.race-human .header-stat:nth-child(2) input[type="number"] {
            background: #DCBB78;
        }

        .character-card.race-dragonborn .header-top-section,
        .character-card.race-dragonborn .header-bottom-section,
        .character-card.race-dragonborn .header-stat:nth-child(2) input[type="number"] {
            background: #FFE0D3;
        }

        .character-card.race-elf .header-top-section,
        .character-card.race-elf .header-bottom-section,
        .character-card.race-elf .header-stat:nth-child(2) input[type="number"] {
            background: #CFDDCD;
        }

        .character-card.race-gnome .header-top-section,
        .character-card.race-gnome .header-bottom-section,
        .character-card.race-gnome .header-stat:nth-child(2) input[type="number"] {
            background: #D7DDCD;
        }

        .character-card.race-half-elf .header-top-section,
        .character-card.race-half-elf .header-bottom-section,
        .character-card.race-half-elf .header-stat:nth-child(2) input[type="number"] {
            background: #CFDDCD;
        }

        .character-card.race-halfling .header-top-section,
        .character-card.race-halfling .header-bottom-section,
        .character-card.race-halfling .header-stat:nth-child(2) input[type="number"] {
            background: #BDA89B;
        }

        .character-card.race-dwarf .header-top-section,
        .character-card.race-dwarf .header-bottom-section,
        .character-card.race-dwarf .header-stat:nth-child(2) input[type="number"] {
            background: #DCBB78;
        }

        .character-card.race-tiefling .header-top-section,
        .character-card.race-tiefling .header-bottom-section,
        .character-card.race-tiefling .header-stat:nth-child(2) input[type="number"] {
            background: #DCBB78;
        }

        .character-card.race-half-orc .header-top-section,
        .character-card.race-half-orc .header-bottom-section,
        .character-card.race-half-orc .header-stat:nth-child(2) input[type="number"] {
            background: #DCBB78;
        }

        /* NUCLEAR OPTION: Force HP shield to always be gold gradient */
        .character-card .header-stat:first-child .ac-inputs,
        .character-card.race-human .header-stat:first-child .ac-inputs,
        .character-card.race-dragonborn .header-stat:first-child .ac-inputs,
        .character-card.race-elf .header-stat:first-child .ac-inputs,
        .character-card.race-gnome .header-stat:first-child .ac-inputs,
        .character-card.race-half-elf .header-stat:first-child .ac-inputs,
        .character-card.race-halfling .header-stat:first-child .ac-inputs,
        .character-card.race-dwarf .header-stat:first-child .ac-inputs,
        .character-card.race-tiefling .header-stat:first-child .ac-inputs,
        .character-card.race-half-orc .header-stat:first-child .ac-inputs {
            background: linear-gradient(180deg, #602D12 0%, #713A17 36.98%, #4A1C0D 77.08%, #50210F 96.87%), #86543B !important;
            box-shadow: 2px -2px 3px 0 rgba(255, 255, 255, 0.40) inset, -2px 4px 4px 0 rgba(35, 35, 35, 0.70) inset !important;
        }

        /* NUCLEAR OPTION: Force HP shield inputs to be transparent */
        .character-card .header-stat:first-child .ac-input,
        .character-card .header-stat:first-child input.ac-input,
        .character-card .header-stat:first-child input.editable-field.ac-input,
        .character-card.race-human .header-stat:first-child .ac-input,
        .character-card.race-dragonborn .header-stat:first-child .ac-input,
        .character-card.race-elf .header-stat:first-child .ac-input,
        .character-card.race-gnome .header-stat:first-child .ac-input,
        .character-card.race-half-elf .header-stat:first-child .ac-input,
        .character-card.race-halfling .header-stat:first-child .ac-input,
        .character-card.race-dwarf .header-stat:first-child .ac-input,
        .character-card.race-tiefling .header-stat:first-child .ac-input,
        .character-card.race-half-orc .header-stat:first-child .ac-input {
            background: transparent !important;
        }



        .card-title {
            margin-bottom: 4px;
        }

        .card-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #000000;
            background: transparent;
            border: none;
            width: 100%;
            padding: 2px 8px;
            font-family: 'Merriweather', serif;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .header-top-section {
            background: #DCBB78;
            border: 2px solid #000;
            border-radius: 8px;
            padding: 8px 12px;
            position: relative;
            box-shadow: 
                -1.5px 4.5px 1.5px 0 rgba(255, 255, 255, 0.40) inset, 
                4.5px -4.5px 1.5px 0 rgba(68, 68, 68, 0.20) inset, 
                4.5px 0 1.5px 0 rgba(68, 68, 68, 0.20) inset, 
                0 -4.5px 1.5px 0 rgba(51, 51, 51, 0.50) inset;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-bottom-section {
            background: #DCBB78;
            border: 2px solid #000;
            border-radius: 8px 8px 0 0;
            padding: 6px 12px 20px 12px;
            box-shadow: 
                -1.5px 4.5px 1.5px 0 rgba(255, 255, 255, 0.40) inset, 
                4.5px -4.5px 1.5px 0 rgba(68, 68, 68, 0.20) inset, 
                4.5px 0 1.5px 0 rgba(68, 68, 68, 0.20) inset, 
                0 -4.5px 1.5px 0 rgba(51, 51, 51, 0.50) inset;
            display: flex;
            flex-direction: column;
            gap: 0px;
            position: relative;
        }

        .header-stats {
            display: flex;
            gap: 2px;
            position: absolute;
            right: -15px;
            top: -10px;
            z-index: 10;
        }



        .header-stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .header-stat input[type="number"] {
            background: #DCBB78;
            color: #000000;
            border: 1px solid #000000;
            border-radius: 4px;
            padding: 4px 8px;
            width: 50px;
            text-align: center;
            font-weight: 600;
        }

        .header-stat:nth-child(2) {
            position: relative;
        }



        .header-stat:nth-child(2) .heart-icon,
        .header-stat:nth-child(2) .ac-inputs {
            position: relative;
            z-index: 3;
        }

        .header-stat:nth-child(2) .ac-inputs {
            background: linear-gradient(180deg, #602D12 0%, #713A17 36.98%, #4A1C0D 77.08%, #50210F 96.87%), #86543B !important;
            box-shadow: 2px -2px 3px 0 rgba(255, 255, 255, 0.40) inset, -2px 4px 4px 0 rgba(35, 35, 35, 0.70) inset;
            border-radius: 18px;
            padding: 4px 10px;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .ac-inputs {
            display: flex;
            align-items: center;
            gap: 0px;
        }

        .ac-input {
            background: transparent !important;
            color: #FFFFFF;
            border: none !important;
            border-radius: 0;
            padding: 0;
            width: 32px;
            min-width: 32px;
            text-align: center;
            font-weight: 700;
            font-size: 1rem;
            outline: none;
        }

        .ac-separator {
            color: #FFFFFF;
            font-weight: 700;
            font-size: 0.85rem;
            margin: 0;
        }

        .heart-icon {
            font-size: 1rem;
            margin: 0;
        }

        /* Remove number input arrows for AC inputs */
        .ac-input::-webkit-outer-spin-button,
        .ac-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .ac-input {
            -moz-appearance: textfield;
        }

        .ac-input:focus {
            outline: none;
            border: none;
            background: transparent !important;
        }

        .header-stat:nth-child(2) .ac-input {
            background: transparent !important;
            color: #FFFFFF !important;
            width: 32px !important;
            min-width: 32px;
            padding: 0 !important;
            border: none !important;
            border-radius: 0 !important;
            font-size: 0.85rem !important;
            font-weight: 700 !important;
        }

        /* Hexagonal HP input */
        .hex-wrapper {
            position: relative;
            width: 41px;
            height: 41px;
            background: #000000;
            clip-path: polygon(50% 0%, 85% 15%, 85% 60%, 50% 90%, 15% 60%, 15% 15%);
            -webkit-clip-path: polygon(50% 0%, 85% 15%, 85% 60%, 50% 90%, 15% 60%, 15% 15%);
        }
        
        .header-stat:first-child input[type="number"] {
            background: linear-gradient(300deg, #DFCC66 14.12%, #E1D485 46.07%, #F0EECC 86.42%);
            color: #000000;
            border: none;
            width: 35px;
            height: 35px;
            padding: 0;
            text-align: center;
            font-weight: 700;
            font-size: 0.9rem;
            clip-path: polygon(50% 0%, 85% 15%, 85% 60%, 50% 90%, 15% 60%, 15% 15%);
            -webkit-clip-path: polygon(50% 0%, 85% 15%, 85% 60%, 50% 90%, 15% 60%, 15% 15%);
            box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.3), inset 0 -1px 2px rgba(0, 0, 0, 0.2);
            position: absolute;
            top: 3px;
            left: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            padding-bottom: 5px;
        }
        
        .header-stat:first-child input[type="number"]:hover {
            background: linear-gradient(300deg, #E8D675 14.12%, #E9D994 46.07%, #F5F2D4 86.42%);
            box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.4), inset 0 -1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .header-stat:first-child input[type="number"]:focus {
            outline: none;
            background: #E8D675;
        }
        
        /* Remove number input arrows */
        .header-stat:first-child input[type="number"]::-webkit-outer-spin-button,
        .header-stat:first-child input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        .header-stat:first-child input[type="number"] {
            -moz-appearance: textfield;
        }

        .card-name:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #a0522d;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .card-type {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 3px;
        }

        .card-class {
            font-size: 1.08rem;
            font-weight: 600;
            color: #2c1810;
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(139, 115, 85, 0.3);
            width: 60%;
            padding: 3px 6px;
            font-family: 'Times New Roman', serif;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .card-class:focus {
            outline: none;
            background: rgba(255, 255, 255, 1);
            border: 1px solid #a0522d;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.15), 0 0 0 2px rgba(160, 82, 45, 0.3);
        }

        .card-level {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3a 100%);
            color: #ffd700;
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 0.81rem;
            border: 1px solid #a0522d;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 1px 2px rgba(0, 0, 0, 0.4);
        }

        .level-input {
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(139, 115, 85, 0.3);
            color: #2c1810;
            width: 2.5rem;
            text-align: center;
            font-weight: bold;
            font-size: 0.81rem;
            font-family: 'Times New Roman', serif;
            border-radius: 4px;
        }

        .level-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 1);
            border: 1px solid #a0522d;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.15), 0 0 0 2px rgba(160, 82, 45, 0.3);
        }

        .card-race {
            font-size: 0.81rem;
            color: #b0b0b0;
            font-style: italic;
        }

        .race-input {
            background: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(139, 115, 85, 0.3);
            color: #5c4a3a;
            font-style: italic;
            width: 100%;
            padding: 3px 6px;
            font-family: 'Times New Roman', serif;
            font-size: 0.81rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .race-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 1);
            border: 1px solid #a0522d;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.15), 0 0 0 2px rgba(160, 82, 45, 0.3);
            border: 1px solid #a0522d;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .card-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .card-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 6px;
        }

        .stat-row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
        }

        .stat-label {
            font-weight: bold;
            color: #ffd700;
            min-width: 2.5rem;
            font-size: 0.81rem;
        }

        .stat-input {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            border: 1px solid #8b7355;
            border-radius: 4px;
            padding: 6px 8px;
            width: 4rem;
            text-align: center;
            font-family: 'Times New Roman', serif;
            color: #e0e0e0;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .stat-input:focus {
            outline: none;
            border-color: #a0522d;
            background: linear-gradient(180deg, #5a5a5a 0%, #4a4a4a 100%);
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 0 2px rgba(160, 82, 45, 0.3);
        }

        .card-abilities {
            flex: 1;
        }

        .ability-grid {
            display: flex;
            justify-content: space-between;
            gap: 0px;
            flex-wrap: wrap;
        }

        .ability-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1px;
            flex: 1;
            max-width: 35px;
        }

        .ability-label {
            font-size: 0.7rem;
            font-weight: 700;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 2px;
        }

        .stat-shield-wrapper {
            position: relative;
            width: 45px;
            height: 36px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='107' height='83' viewBox='0 0 107 83' fill='none'%3E%3Cg filter='url(%23filter0_ddii_6_396201)'%3E%3Cpath d='M15.6037 42.7525C15.0682 43.3716 15.1903 44.4322 15.9198 44.8037C23.0544 48.4369 51.9225 63.0908 53.4108 63.0908C54.913 63.0908 84.3066 48.1631 91.0953 44.7052C91.7785 44.3572 91.926 43.406 91.4883 42.7765C90.1543 40.8581 87.9555 36.5611 87.9555 29.0784C87.9555 23.0651 91.5097 14.221 92.9867 10.8053C93.2885 10.1072 92.8329 9.31156 92.0755 9.24168C86.4648 8.72402 66.7766 7.0001 53.4108 7.0001C40.3513 7.0001 21.2556 8.64595 15.1537 9.20425C14.2952 9.28279 13.8465 10.2887 14.3059 11.0181C16.2302 14.0741 19.9988 21.0799 19.9988 29.0784C19.9988 36.53 17.2731 40.8224 15.6037 42.7525Z' fill='url(%23paint0_linear_6_396201)'/%3E%3C/g%3E%3Cdefs%3E%3Cfilter id='filter0_ddii_6_396201' x='0.903583' y='0.390512' width='105.396' height='82.5288' filterUnits='userSpaceOnUse' color-interpolation-filters='sRGB'%3E%3CfeFlood flood-opacity='0' result='BackgroundImageFix'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dy='6.60949'/%3E%3CfeGaussianBlur stdDeviation='6.60949'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.4 0'/%3E%3CfeBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow_6_396201'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dy='2.20316'/%3E%3CfeGaussianBlur stdDeviation='2.20316'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.65 0'/%3E%3CfeBlend mode='normal' in2='effect1_dropShadow_6_396201' result='effect2_dropShadow_6_396201'/%3E%3CfeBlend mode='normal' in='SourceGraphic' in2='effect2_dropShadow_6_396201' result='shape'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dx='1.10158' dy='-1.10158'/%3E%3CfeGaussianBlur stdDeviation='1.10158'/%3E%3CfeComposite in2='hardAlpha' operator='arithmetic' k2='-1' k3='1'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0.223529 0 0 0 0 0.184314 0 0 0 0 0.145098 0 0 0 0.6 0'/%3E%3CfeBlend mode='normal' in2='shape' result='effect3_innerShadow_6_396201'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dx='-1.10158' dy='1.10158'/%3E%3CfeGaussianBlur stdDeviation='1.10158'/%3E%3CfeComposite in2='hardAlpha' operator='arithmetic' k2='-1' k3='1'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0.882422 0 0 0 0 0.87413 0 0 0 0 0.832671 0 0 0 1 0'/%3E%3CfeBlend mode='normal' in2='effect3_innerShadow_6_396201' result='effect4_innerShadow_6_396201'/%3E%3C/filter%3E%3ClinearGradient id='paint0_linear_6_396201' x1='53.4108' y1='63.0908' x2='53.4108' y2='7.0001' gradientUnits='userSpaceOnUse'%3E%3Cstop stop-color='%23E9EAEC'/%3E%3Cstop offset='0.385417' stop-color='%23E7E6E5'/%3E%3Cstop offset='0.71875' stop-color='%23DFDFE1'/%3E%3Cstop offset='1' stop-color='%23DFDEE3'/%3E%3C/linearGradient%3E%3C/defs%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .stat-shield-wrapper::before {
            content: '';
            position: absolute;
            top: calc(45% - 1px);
            left: 50%;
            transform: translate(-50%, -50%);
            width: 28px;
            height: 19px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='66' height='45' viewBox='0 0 66 45' fill='none'%3E%3Cg filter='url(%23filter0_d_6_396202)'%3E%3Cpath d='M3.95285 29.7333C3.93233 30.0474 4.08932 30.3338 4.37428 30.4675C7.92686 32.1352 31.0762 42.9824 32.1645 42.9824C33.256 42.9824 56.5449 32.0682 59.9869 30.4524C60.255 30.3265 60.4105 30.0651 60.4114 29.769C60.4165 28.0844 60.4498 22.4451 60.6647 19.8644C61.0059 15.7664 62.6399 8.90147 63.2399 6.47406C63.3539 6.01283 63.0284 5.55756 62.5546 5.52195C58.4867 5.2162 41.7054 3.99993 32.1645 3.99993C22.6572 3.99993 6.82033 5.20762 2.89895 5.51868C2.42662 5.55615 2.10637 6.00861 2.21872 6.46892C2.81941 8.93006 4.45014 15.9701 4.45014 19.8644C4.45014 21.9603 4.07051 27.9326 3.95285 29.7333Z' fill='%23191621'/%3E%3C/g%3E%3Cdefs%3E%3Cfilter id='filter0_d_6_396202' x='-0.00687361' y='0.695256' width='65.4727' height='43.3887' filterUnits='userSpaceOnUse' color-interpolation-filters='sRGB'%3E%3CfeFlood flood-opacity='0' result='BackgroundImageFix'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dy='-1.10158'/%3E%3CfeGaussianBlur stdDeviation='1.10158'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0.0980392 0 0 0 0 0.0862745 0 0 0 0 0.129412 0 0 0 1 0'/%3E%3CfeBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow_6_396202'/%3E%3CfeBlend mode='normal' in='SourceGraphic' in2='effect1_dropShadow_6_396202' result='shape'/%3E%3C/filter%3E%3C/defs%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 1;
        }

        .ability-input {
            background: transparent;
            color: #FFFFFF;
            border: none;
            width: 45px;
            height: 36px;
            padding: 0;
            text-align: center;
            font-weight: 700;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: absolute;
            top: -3px;
            left: 0;
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ability-input:hover {
            background: rgba(232, 214, 117, 0.3);
        }

        .ability-input:focus {
            outline: none;
            background: rgba(232, 214, 117, 0.5);
        }

        /* Remove spin buttons for stat inputs */
        .ability-input::-webkit-outer-spin-button,
        .ability-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .ability-input[type=number] {
            -moz-appearance: textfield;
        }

        .custom-abilities {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #8b7355;
        }

        .custom-ability-item {
            margin-bottom: 6px;
        }

        .custom-ability-label {
            display: block;
            font-size: 0.8rem;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 2px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .custom-ability-input {
            width: 100%;
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            border: 1px solid #8b7355;
            border-radius: 4px;
            padding: 4px 6px;
            font-family: "Times New Roman", serif;
            color: #e0e0e0;
            font-size: 0.8rem;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .custom-ability-input:focus {
            outline: none;
            border-color: #a0522d;
            background: linear-gradient(180deg, #5a5a5a 0%, #4a4a4a 100%);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 0 0 2px rgba(160, 82, 45, 0.3);
        }

        .card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 8px;
            padding-top: 8px;
            position: absolute;
            bottom: 8px;
            left: 8px;
            right: 8px;
            margin-left: -10px;
            margin-right: -10px;
            padding-left: 10px;
            padding-right: 10px;
        }

        .footer-left,
        .footer-right {
            flex: 0 0 auto;
        }

        .footer-center {
            flex: 1;
            display: flex;
            justify-content: center;
        }

        /* Death Saves UI */
        .death-saves {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .death-saves-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: #8b7355;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Times New Roman', serif;
        }

        .death-saves-bubbles {
            display: flex;
            gap: 6px;
        }

        .death-save-bubble {
            width: 12px;
            height: 12px;
            border: 2px solid #8b7355;
            border-radius: 50%;
            background: transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .death-save-bubble:hover {
            border-color: #a0522d;
        }

        .death-save-bubble.filled {
            background: #8b0000;
            border-color: #a0522d;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3), 0 0 4px rgba(139, 0, 0, 0.3);
        }

        /* Enemy Footer Controls */
        .attack-btn, .hide-toggle-btn {
            background: linear-gradient(135deg, #8b0000 0%, #a0522d 100%);
            border: 2px solid #654321;
            color: #ffffff;
            font-size: 0.8rem;
            font-weight: bold;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0 4px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .attack-btn:hover, .hide-toggle-btn:hover {
            background: linear-gradient(135deg, #a0522d 0%, #8b0000 100%);
            border-color: #8b4513;
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        }

        .hide-toggle-btn.hidden {
            background: linear-gradient(135deg, #4a4a4a 0%, #666666 100%);
            border-color: #333333;
        }

        .hide-toggle-btn.hidden:hover {
            background: linear-gradient(135deg, #666666 0%, #4a4a4a 100%);
            border-color: #555555;
        }

        /* Attack Overlay - positioned on card */
        .attack-overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2a1810 0%, #1a0f08 100%);
            border: 3px solid #8b0000;
            border-radius: 12px;
            padding: 15px;
            width: 240px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9);
            z-index: 2000;
            backdrop-filter: blur(2px);
        }

        .attack-overlay::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            z-index: -1;
        }

        .attack-overlay h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-family: 'Times New Roman', serif;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 1.1rem;
        }

        .damage-input {
            width: 80px;
            padding: 6px;
            font-size: 1.1rem;
            text-align: center;
            border: 2px solid #8b0000;
            border-radius: 6px;
            background: #1a1a1a;
            color: #ffffff;
            margin: 8px;
        }

        .attack-overlay-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 12px;
        }

        .attack-confirm-btn, .attack-cancel-btn {
            padding: 6px 12px;
            border: 2px solid;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .attack-confirm-btn {
            background: linear-gradient(135deg, #8b0000 0%, #a0522d 100%);
            border-color: #654321;
            color: #ffffff;
        }

        .attack-cancel-btn {
            background: linear-gradient(135deg, #4a4a4a 0%, #666666 100%);
            border-color: #333333;
            color: #ffffff;
        }

        .attack-confirm-btn:hover {
            background: linear-gradient(135deg, #a0522d 0%, #8b0000 100%);
            transform: translateY(-1px);
        }

        .attack-cancel-btn:hover {
            background: linear-gradient(135deg, #666666 0%, #4a4a4a 100%);
            transform: translateY(-1px);
        }



        /* Hidden monster cards */
        .character-card.hidden-monster {
            transition: all 0.3s ease;
        }

        /* Card flip animation */
        .character-card {
            transform-style: preserve-3d;
            transition: transform 0.8s ease-in-out;
        }

        .character-card.flipping {
            transform: rotateY(180deg);
        }

        /* Immediate content fade during flip - no transition delay */
        .character-card.flipping > *:not(.card-footer) {
            opacity: 0 !important;
            transition: opacity 0.15s ease-out;
        }

        .character-card.flipping .card-footer {
            opacity: 0.3 !important;
            transition: opacity 0.15s ease-out;
        }

        /* Content fade back in after flip */
        .character-card.flip-content-ready > *:not(.card-footer) {
            opacity: 1 !important;
            transition: opacity 0.3s ease-in;
        }

        .character-card.flip-content-ready .card-footer {
            opacity: 1 !important;
            transition: opacity 0.3s ease-in;
        }

        /* Hide all content except footer when card is hidden - use visibility to maintain layout */
        .character-card.hidden-monster > *:not(.card-footer) {
            visibility: hidden;
        }

        /* Adjust card appearance when hidden but keep same size */
        .character-card.hidden-monster {
            background: #1a0f0f;
            border: 2px solid #3a1515;
            position: relative;
        }

        /* Add custom card-back image - covers main card area only, not footer */
        .character-card.hidden-monster::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 50px; /* Leave space for footer - adjusted for new height */
            background: url('cards-backs/card_back_1.png') center center / contain no-repeat;
            border-radius: 8px 8px 0 0; /* Only round top corners */
            pointer-events: none;
            z-index: 10; /* Ensure it's above other content */
            opacity: 1;
            transition: opacity 0.15s ease-out;
        }

        /* Make card-back fade out during flip animation just like front content */
        .character-card.flipping.hidden-monster::before {
            opacity: 0 !important;
            transition: opacity 0.15s ease-out;
        }

        /* Make card-back fade back in after flip */
        .character-card.flip-content-ready.hidden-monster::before {
            opacity: 1 !important;
            transition: opacity 0.3s ease-in;
        }

        /* Ensure card-back doesn't show when not hidden - use opacity instead of display */
        .character-card:not(.hidden-monster)::before {
            opacity: 0;
            transition: opacity 0.15s ease-out;
        }

        .remove-card-btn {
            background: linear-gradient(180deg, #8b0000 0%, #6b0000 100%);
            color: #ffd700;
            border: 2px solid #a0522d;
            border-radius: 6px;
            width: 2.5rem;
            height: 1.8rem;
            font-size: 1.08rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .remove-card-btn:hover {
            background: linear-gradient(180deg, #a00000 0%, #8b0000 100%);
            transform: scale(1.05);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        /* Open Deck Button */
        .open-deck-btn {
            background: linear-gradient(180deg, #4a6b4a 0%, #2a4a2a 100%);
            color: #d4af8c;
            border: 2px solid #5a7355;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
            font-family: 'Times New Roman', serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .open-deck-btn:hover {
            background: linear-gradient(180deg, #5a7a5a 0%, #3a5a3a 100%);
            transform: translateY(-1px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .open-deck-btn.deck-open {
            background: linear-gradient(180deg, #6b4a4a 0%, #4a2a2a 100%);
            border-color: #7a5555;
        }

        /* Deck Popup Window */
        .deck-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            background: #040E08;
            border: none;
            border-radius: 0;
            z-index: 1100;
            box-shadow: none;
            backdrop-filter: none;
            overflow-y: auto;
        }



        .deck-popup.open {
            display: flex;
            flex-direction: column;
            animation: deckPopupOpen 0.6s ease-out;
        }

        @keyframes deckPopupOpen {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .deck-popup.closing {
            display: flex;
            flex-direction: column;
            animation: deckPopupClose 1.0s ease-out forwards;
        }

        @keyframes deckPopupClose {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        /* Main page transition animations removed */

        .deck-popup-content {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .deck-popup-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(180deg, #8b0000 0%, #6b0000 100%);
            color: #ffd700;
            border: 1px solid #a0522d;
            border-radius: 4px;
            width: 1.5rem;
            height: 1.5rem;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: auto;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .deck-popup-close:hover {
            background: linear-gradient(180deg, #a00000 0%, #8b0000 100%);
            transform: scale(1.1);
        }

        /* New Deck Layout */
        .deck-main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 40px;
            gap: 20px;
            min-height: 100%;
        }

        /* Legacy styles - keeping for compatibility */

        .deck-title {
            color: #ffd700;
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            font-family: 'Times New Roman', serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            width: 100%;
        }

        .deck-character-display {
            display: flex;
            justify-content: center;
            width: 100%;
            /* Removed height constraint - let the card determine its own height */
            margin-bottom: -500px; /* Negative margin to create overlay effect */
            padding: 20px;
            position: relative;
            pointer-events: none;
        }

        /* Deck character card positioning and layout constraints */
        .deck-character-display .character-card {
            z-index: 1000;
            pointer-events: auto;
            min-height: 534.5px; /* Match actual main page card height */
            max-height: 534.5px; /* Prevent growth that causes page shifting */
        }
        
        .deck-character-display .character-card.deck-positioned {
            transform: scale(0.9) translateY(-40px);
        }

        .deck-content-rows {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .deck-rows-container {
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .deck-row-spells,
        .deck-row-items {
            flex: 1;
            min-width: 0;
            box-sizing: border-box;
        }

        /* Clean styling for sections */
        .deck-row-items {
            padding: 10px;
            max-width: 50%;
            overflow: hidden;
        }

        .deck-row-spells {
            padding: 10px;
            max-width: 50%;
            overflow: hidden;
        }

        .deck-row-items .deck-row-header {
            padding: 5px;
            text-align: center;
            padding-left: 0;
        }

        .deck-row-spells .deck-row-header {
            padding: 5px;
            text-align: center;
            padding-left: 0;
        }

        /* Full width rows layout */

        /* Scrollable Rows */
        .deck-row {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            width: 100%;
        }

        /* Fade effects for deck rows - copied from monster library */
        .deck-row::before,
        .deck-row::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 120px; /* Fade width */
            z-index: 10;
            pointer-events: none;
        }

        .deck-row::before {
            left: 0;
            background: linear-gradient(to right, 
                rgba(4, 14, 8, 1) 0%, 
                rgba(4, 14, 8, 0.9) 20%, 
                rgba(4, 14, 8, 0.6) 50%, 
                rgba(4, 14, 8, 0) 100%);
        }

        .deck-row::after {
            right: 0;
            background: linear-gradient(to left, 
                rgba(4, 14, 8, 1) 0%, 
                rgba(4, 14, 8, 0.9) 20%, 
                rgba(4, 14, 8, 0.6) 50%, 
                rgba(4, 14, 8, 0) 100%);
        }

        .deck-row-header {
            color: #ffd700;
            font-size: 12px;
            font-weight: bold;
            font-family: 'Times New Roman', serif;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
            padding-left: 140px; /* Offset to match content padding */
            flex: 0 0 auto;
        }

        .deck-row-content {
            flex: 0 0 auto;
            overflow-x: auto;
            overflow-y: visible;
            padding: 0;
        }

        .deck-row-scroll {
            display: flex;
            gap: 15px;
            align-items: flex-start;
            min-width: min-content;
            transform: scale(0.8);
            transform-origin: left top;
            padding-bottom: 5px; /* Minimal space to prevent cutoff */
            padding-left: 130px; /* Offset content from left fade gradient */
            padding-right: 130px; /* Offset content from right fade gradient */
        }

        /* Hide horizontal scrollbars but show vertical scrollbar for right column */
        .deck-right-column::-webkit-scrollbar {
            width: 8px;
        }

        .deck-right-column::-webkit-scrollbar-track {
            background: rgba(74, 107, 74, 0.1);
            border-radius: 4px;
        }

        .deck-right-column::-webkit-scrollbar-thumb {
            background: rgba(139, 115, 85, 0.6);
            border-radius: 4px;
        }

        .deck-right-column::-webkit-scrollbar-thumb:hover {
            background: rgba(139, 115, 85, 0.8);
        }

        /* Hide scrollbars */
        .deck-row-content::-webkit-scrollbar {
            display: none;
        }

        .deck-row-content {
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .deck-scroll-container::-webkit-scrollbar {
            display: none;
        }

        .deck-scroll-container {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* Internet Explorer 10+ */
        }

        /* Character Card in Deck Popup */
        .deck-character-card {
            flex: 0 0 320px;
            width: 320px;
            position: relative;
        }

        .deck-character-card.flying {
            animation: flyToPopup 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        @keyframes flyToPopup {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(0.8);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Add Item Button in Deck */
        .deck-add-item {
            flex: 0 0 320px;
            width: 320px;
            height: 380px;
            background: rgba(74, 107, 74, 0.1);
            border: 3px dashed #4a6b4a;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #4a6b4a;
            font-family: 'Times New Roman', serif;
        }

        .deck-add-item:hover {
            background: rgba(74, 107, 74, 0.2);
            border-color: #5a7a5a;
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }

        .deck-add-item-icon {
            font-size: 3.5rem;
            margin-bottom: 14px;
        }

        .deck-add-item-text {
            font-size: 1.1rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .deck-add-item-subtext {
            font-size: 0.85rem;
            margin-top: 7px;
            opacity: 0.8;
        }

        /* Item Cards in Deck Popup */
        .deck-item-card {
            flex: 0 0 320px;
            width: 320px;
        }

        /* Base Item Card Styling */
        .item-card {
            background: #17140F;
            border: none;
            border-radius: 8px;
            padding: 18px;
            padding-bottom: 60px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 6px 12px rgba(0, 0, 0, 0.6);
            position: relative;
            transition: all 0.3s ease;
            min-height: 380px;
            max-width: 320px;
            width: 100%;
            display: flex;
            flex-direction: column;
            overflow: visible;
        }

        .item-card:hover {
            transform: translateY(-3px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                0 8px 16px rgba(0, 0, 0, 0.8);
        }

        .item-card-header {
            margin-bottom: 15px;
            z-index: 1;
            position: relative;
        }

        .item-card-name {
            background: transparent;
            border: none;
            color: #ffd700;
            font-size: 1.2rem;
            font-weight: bold;
            font-family: 'Times New Roman', serif;
            text-align: center;
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .item-card-name:focus {
            outline: none;
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.3);
        }

        .item-card-body {
            flex: 1;
            z-index: 1;
            position: relative;
            margin-bottom: 15px;
        }

        .item-card-description {
            width: 100%;
            height: 100%;
            min-height: 200px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #8b7355;
            border-radius: 4px;
            padding: 12px;
            color: #e0e0e0;
            font-family: 'Times New Roman', serif;
            font-size: 0.9rem;
            line-height: 1.4;
            resize: vertical;
            transition: all 0.2s ease;
        }

        .item-card-description:focus {
            outline: none;
            border-color: #a0522d;
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 0 2px rgba(160, 82, 45, 0.3);
        }

        .item-card-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border-top: 2px solid #8b7355;
            border-radius: 0 0 5px 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            z-index: 2;
        }

        .item-card-type {
            color: #4a6b4a;
            font-weight: bold;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Times New Roman', serif;
        }

        .delete-item-btn {
            background: linear-gradient(180deg, #8b0000 0%, #6b0000 100%);
            color: #ffd700;
            border: 2px solid #a0522d;
            border-radius: 4px;
            width: 2rem;
            height: 2rem;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .delete-item-btn:hover {
            background: linear-gradient(180deg, #a00000 0%, #8b0000 100%);
            transform: scale(1.05);
        }

        /* Spell Cards */
        .spell-card {
            background: #0F1317; /* Slightly different from item cards */
            border: none;
            border-radius: 8px;
            padding: 18px;
            padding-bottom: 60px;
            box-shadow: 
                inset 0 1px 0 rgba(138, 43, 226, 0.1), /* Purple tint */
                0 6px 12px rgba(0, 0, 0, 0.6);
            position: relative;
            transition: all 0.3s ease;
            min-height: 380px;
            max-width: 320px;
            width: 100%;
            display: flex;
            flex-direction: column;
            overflow: visible;
            flex: 0 0 320px;
        }

        .spell-card:hover {
            transform: translateY(-3px);
            box-shadow: 
                inset 0 1px 0 rgba(138, 43, 226, 0.2),
                0 8px 16px rgba(138, 43, 226, 0.3);
        }

        .spell-card .card-texture {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(75, 0, 130, 0.15) 0%, rgba(138, 43, 226, 0.1) 100%);
            opacity: 0.8;
            border-radius: 6px;
            pointer-events: none;
            z-index: 1;
        }

        /* Spell Card Image Section */
        .spell-card-image-section {
            display: flex;
            justify-content: center;
            margin: 0 -12px 16px -12px;
            position: relative;
            z-index: 2;
        }

        .spell-card-image {
            width: 100%;
            height: 180px; /* Adjusted for 16:9 aspect ratio */
            object-fit: cover;
            border-radius: 6px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .spell-card:hover .spell-card-image {
            border-color: rgba(138, 43, 226, 0.5);
            box-shadow: 
                0 6px 12px rgba(138, 43, 226, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .spell-card-header {
            margin-bottom: 15px;
            z-index: 1;
            position: relative;
        }

        .spell-card-name {
            background: transparent;
            border: none;
            color: #da70d6; /* Orchid color for spells */
            font-size: 1.2rem;
            font-weight: bold;
            font-family: 'Times New Roman', serif;
            text-align: center;
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
            z-index: 1;
            position: relative;
        }

        .spell-card-name:focus {
            outline: none;
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid #da70d6;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .spell-card-body {
            flex: 1;
            z-index: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .spell-card-level {
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid #da70d6;
            border-radius: 4px;
            padding: 4px 8px;
            font-family: 'Times New Roman', serif;
            color: #da70d6;
            font-size: 0.9rem;
            font-weight: bold;
            text-align: center;
            width: 100%;
        }

        .spell-card-description {
            background: transparent;
            border: none;
            color: #e0e0e0;
            font-family: 'Times New Roman', serif;
            font-size: 0.85rem;
            line-height: 1.4;
            resize: vertical;
            width: 100%;
            min-height: 80px;
            padding: 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
            z-index: 1;
            position: relative;
        }

        .spell-card-description:focus {
            outline: none;
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid #da70d6;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .spell-card-footer {
            position: absolute;
            bottom: 18px;
            left: 18px;
            right: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1;
        }

        .spell-card-school {
            background: rgba(138, 43, 226, 0.3);
            color: #da70d6;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Times New Roman', serif;
        }

        /* Add Spell Button */
        .deck-add-spell {
            flex: 0 0 320px;
            width: 320px;
            height: 380px;
            background: rgba(138, 43, 226, 0.1);
            border: 3px dashed #da70d6;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #da70d6;
            font-family: 'Times New Roman', serif;
        }

        .deck-add-spell:hover {
            background: rgba(138, 43, 226, 0.2);
            border-color: #dda0dd;
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(138, 43, 226, 0.4);
        }

        .deck-add-spell-icon {
            font-size: 3.5rem;
            margin-bottom: 14px;
        }

        .deck-add-spell-text {
            font-size: 1.1rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .deck-add-spell-subtext {
            font-size: 0.85rem;
            margin-top: 7px;
            opacity: 0.8;
        }

        .deck-overlay-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #8b7355;
        }

        .deck-overlay-title {
            color: #ffd700;
            font-size: 1.4rem;
            font-weight: bold;
            font-family: 'Times New Roman', serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .deck-close-btn {
            background: linear-gradient(180deg, #8b0000 0%, #6b0000 100%);
            color: #ffd700;
            border: 2px solid #a0522d;
            border-radius: 6px;
            width: 2.5rem;
            height: 2.5rem;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .deck-close-btn:hover {
            background: linear-gradient(180deg, #a00000 0%, #8b0000 100%);
            transform: scale(1.05);
        }

        .deck-items-section {
            position: relative;
        }

        .deck-items-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .deck-items-title {
            color: #ffd700;
            font-size: 1.2rem;
            font-weight: bold;
            font-family: 'Times New Roman', serif;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .add-item-btn {
            background: linear-gradient(180deg, #4a6b4a 0%, #2a4a2a 100%);
            color: #d4af8c;
            border: 2px solid #5a7355;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Times New Roman', serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .add-item-btn:hover {
            background: linear-gradient(180deg, #5a7a5a 0%, #3a5a3a 100%);
            transform: translateY(-1px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .deck-items-container {
            position: relative;
            overflow: hidden;
            border-radius: 8px;
        }

        .deck-items {
            display: flex;
            gap: 20px;
            padding: 10px;
            overflow-x: auto;
            scroll-behavior: smooth;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .deck-items::-webkit-scrollbar {
            display: none;
        }

        .deck-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            left: 0;
            right: 0;
            padding: 0 10px;
        }

        .deck-nav-btn {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3a 100%);
            color: #ffd700;
            border: 2px solid #a0522d;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .deck-nav-btn:hover {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            transform: scale(1.1);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 6px 12px rgba(0, 0, 0, 0.8);
        }

        .deck-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        /* Item Card Styling - Full Size Like Character Cards */
        .item-card {
            flex: 0 0 320px;
            background: #17140F;
            border: none;
            border-radius: 8px;
            padding: 18px;
            padding-bottom: 60px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 6px 12px rgba(0, 0, 0, 0.6);
            position: relative;
            transition: all 0.3s ease;
            min-height: 380px;
            max-width: 320px;
            width: 320px;
            display: flex;
            flex-direction: column;
        }

        .item-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 12px 40px rgba(74, 107, 74, 0.6);
        }

        .item-card .card-texture {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('textures/human.png') center center / cover;
            opacity: 0.15;
            border-radius: 6px;
            pointer-events: none;
        }

        .item-card-header {
            position: relative;
            z-index: 1;
            margin-bottom: 20px;
            text-align: center;
        }

        .item-card-name {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #8b7355;
            border-radius: 6px;
            padding: 12px 16px;
            font-family: 'Times New Roman', serif;
            color: #2c1810;
            font-size: 1.1rem;
            font-weight: bold;
            width: 100%;
            text-align: center;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.8),
                0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .item-card-name:focus {
            outline: none;
            background: rgba(255, 255, 255, 1);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.8),
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 0 3px rgba(74, 107, 74, 0.3);
        }

        .item-card-body {
            position: relative;
            z-index: 1;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .item-card-description {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #8b7355;
            border-radius: 6px;
            padding: 15px;
            font-family: 'Times New Roman', serif;
            color: #2c1810;
            font-size: 0.9rem;
            min-height: 200px;
            resize: vertical;
            width: 100%;
            flex: 1;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.8),
                0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .item-card-description:focus {
            outline: none;
            background: rgba(255, 255, 255, 1);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.8),
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 0 3px rgba(74, 107, 74, 0.3);
        }

        .item-card-footer {
            position: absolute;
            bottom: 8px;
            left: 8px;
            right: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1;
            padding: 8px 10px;
        }

        .item-card-type {
            color: #4a6b4a;
            font-size: 0.7rem;
            font-weight: bold;
            font-family: 'Times New Roman', serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .delete-item-btn {
            background: linear-gradient(180deg, #8b0000 0%, #6b0000 100%);
            color: #ffd700;
            border: 2px solid #a0522d;
            border-radius: 6px;
            width: 2.5rem;
            height: 1.8rem;
            font-size: 1.08rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .delete-item-btn:hover {
            background: linear-gradient(180deg, #a00000 0%, #8b0000 100%);
            transform: scale(1.05);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .remove-card-btn:active {
            transform: scale(1);
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.4),
                0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .editable-field:focus {
            outline: none;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 0 2px rgba(255, 215, 0, 0.3);
        }

        /* RuneScape-style scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #2a2a2a;
            border: 1px solid #8b7355;
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3a 100%);
            border-radius: 6px;
            border: 1px solid #a0522d;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
        }
            .basic-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            border-top: 1px solid #8b7355;
            padding: 8px 20px;
            color: #ffd700;
            font-family: "Times New Roman", serif;
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.4);
            z-index: 1000;
        }
        .footer-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        .footer-left {
            display: flex;
            align-items: center;
        }
        .footer-middle {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }
        .footer-right {
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }
        .music-player {
            display: flex;
            justify-content: center;
        }
        .runescape-audio {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3a 100%);
            border: 2px solid #a0522d;
            border-radius: 6px;
            padding: 4px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 2px 4px rgba(0, 0, 0, 0.4);
            width: 200px;
            height: 32px;
        }
        .runescape-audio::-webkit-media-controls-panel {
            background: linear-gradient(180deg, #6b5b3a 0%, #4a4a4a 100%);
        }
        .runescape-audio::-webkit-media-controls-play-button {
            background: linear-gradient(180deg, #ffd700 0%, #daa520 100%);
            border: 1px solid #a0522d;
            border-radius: 4px;
        }
        .app-main {
            padding-bottom: 60px;
        }

        /* Abilities Button */
        .abilities-btn {
            background: linear-gradient(180deg, #8b7355 0%, #6b5b3a 100%);
            color: #ffd700;
            border: 2px solid #a0522d;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: 8px;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .abilities-btn:hover {
            background: linear-gradient(180deg, #a0522d 0%, #8b7355 100%);
            transform: scale(1.05);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        /* Abilities Modal */
        .abilities-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        }

        .abilities-modal-content {
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 2px solid #8b7355;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .abilities-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 2px solid #8b7355;
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            border-radius: 10px 10px 0 0;
        }

        .abilities-modal-header h3 {
            color: #ffd700;
            font-size: 1.4rem;
            font-weight: bold;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .close-modal-btn {
            background: linear-gradient(180deg, #8b0000 0%, #6b0000 100%);
            color: #ffd700;
            border: 2px solid #a0522d;
            border-radius: 6px;
            width: 2rem;
            height: 2rem;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .close-modal-btn:hover {
            background: linear-gradient(180deg, #a00000 0%, #8b0000 100%);
            transform: scale(1.05);
        }

        .abilities-modal-body {
            padding: 20px;
        }

        .abilities-modal-body .custom-ability-item {
            margin-bottom: 15px;
        }

        .abilities-modal-body .custom-ability-label {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .abilities-modal-body .custom-ability-input {
            font-size: 0.9rem;
            padding: 8px 10px;
        }

        /* Card Tabs */
        .card-tabs {
            display: flex;
            background: transparent;
            position: absolute;
            bottom: -2px;
            left: 12px;
            right: 12px;
            border-radius: 0 0 8px 8px;
        }

        .tab-btn {
            background: transparent;
            color: #000000;
            border: none;
            padding: 8px 3px;
            font-size: 0.7rem;
            font-weight: 600;
            font-family: 'Merriweather', serif;
            cursor: pointer;
            flex: 1;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tab-btn:hover {
            color: #333333;
        }

        .tab-btn.active {
            background: transparent;
            color: #000000;
            font-weight: 700;
            border-bottom: 4px solid #000000;
        }

        .tab-content {
            display: none;
            background: var(--gold-text, #FCF4DF);
            box-shadow: 1px -3px 3px 0 rgba(255, 255, 255, 0.30) inset, -3px 3px 3px 0 rgba(85, 85, 85, 0.45) inset;
            border-radius: 0 0 8px 8px;
            padding: 0 12px 12px 12px;
            position: relative;
            z-index: 1;
        }

        .tab-content.active {
            display: block;
        }

        /* Abilities Tab Content */
        .abilities-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .abilities-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .abilities-label {
            font-size: 0.75rem;
            font-weight: bold;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .abilities-textarea {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #8b7355;
            border-radius: 4px;
            padding: 4px 6px;
            font-family: 'Times New Roman', serif;
            color: #2c1810;
            font-size: 0.75rem;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
            resize: vertical;
            min-height: 30px;
        }

        .abilities-textarea:focus {
            outline: none;
            border-color: #a0522d;
            background: rgba(255, 255, 255, 1);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.15), 0 0 0 2px rgba(160, 82, 45, 0.3);
        }

        /* Inventory Tab Content */
        .inventory-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .inventory-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .inventory-label {
            font-size: 0.75rem;
            font-weight: bold;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .inventory-input {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #8b7355;
            border-radius: 4px;
            padding: 4px 6px;
            font-family: 'Times New Roman', serif;
            color: #2c1810;
            font-size: 0.75rem;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .inventory-textarea {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #8b7355;
            border-radius: 4px;
            padding: 4px 6px;
            font-family: 'Times New Roman', serif;
            color: #2c1810;
            font-size: 0.75rem;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
            resize: vertical;
            min-height: 40px;
        }

        .inventory-input:focus,
        .inventory-textarea:focus {
            outline: none;
            border-color: #a0522d;
            background: rgba(255, 255, 255, 1);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.15), 0 0 0 2px rgba(160, 82, 45, 0.3);
        }

        /* Story Tab Content */
        .story-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .story-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .story-label {
            font-size: 0.75rem;
            font-weight: bold;
            color: #ffd700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .story-textarea {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #8b7355;
            border-radius: 4px;
            padding: 4px 6px;
            font-family: 'Times New Roman', serif;
            color: #2c1810;
            font-size: 0.75rem;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
            resize: vertical;
            min-height: 30px;
        }

        .story-textarea:focus {
            outline: none;
            border-color: #a0522d;
            background: rgba(255, 255, 255, 1);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.15), 0 0 0 2px rgba(160, 82, 45, 0.3);
        }

        /* Character Image Section */
        .character-image-section {
            display: flex;
            justify-content: center;
            margin: 0 -12px 16px -12px;
        }

        .character-image-placeholder {
            width: 100%;
            height: 160px;
            border: 2px solid #8b7355 inset;
            background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .character-image-placeholder:hover {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
        }

        .image-placeholder-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            text-align: center;
        }

        .image-placeholder-text {
            font-size: 0.8rem;
            font-weight: 600;
            color: #e0e0e0;
        }

        .image-placeholder-subtext {
            font-size: 0.7rem;
            color: #a0a0a0;
        }

        .character-photo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0 0 4px 4px;
            position: absolute;
            top: 0;
            left: 0;
            max-width: 100%;
            max-height: 100%;
        }

        /* Enemy card images should crop from bottom to show heads/faces */
        .character-card.enemy .character-photo {
            object-position: top center;
        }

        .character-image-placeholder {
            position: relative;
            overflow: hidden;
        }

        .character-image-placeholder.has-photo .image-placeholder-content {
            display: none;
        }

        .character-image-placeholder.has-photo:hover .image-placeholder-content {
            display: flex;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
        }

        .character-image-placeholder.has-photo:hover .image-placeholder-text {
            color: #ffffff;
        }

        .character-image-placeholder.has-photo:hover .image-placeholder-subtext {
            color: #cccccc;
        }

        /* Delete Confirmation Overlay - positioned on card */
        .delete-overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2a1810 0%, #1a0f08 100%);
            border: none;
            border-radius: 12px;
            padding: 20px;
            width: 280px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9);
            z-index: 2000;
            backdrop-filter: blur(2px);
        }

        .delete-overlay::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            z-index: -1;
        }

        .delete-overlay h3 {
            color: #ff6b6b;
            margin-bottom: 12px;
            font-family: 'Times New Roman', serif;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 1.1rem;
        }

        .delete-overlay p {
            color: #e0e0e0;
            margin-bottom: 16px;
            font-size: 0.9rem;
            line-height: 1.3;
        }

        .delete-overlay-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 12px;
        }

        .delete-confirm-btn, .delete-cancel-btn {
            padding: 8px 16px;
            border: 2px solid;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.85rem;
            transition: all 0.2s ease;
            font-family: 'Times New Roman', serif;
            outline: none;
        }

        .delete-confirm-btn {
            background: linear-gradient(135deg, #d32f2f 0%, #b71c1c 100%);
            border-color: #f44336;
            color: white;
        }

        .delete-confirm-btn:hover {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
        }

        .delete-cancel-btn {
            background: linear-gradient(135deg, #4a4a4a 0%, #3a3a3a 100%);
            border-color: #666;
            color: #e0e0e0;
        }

        .delete-cancel-btn:hover {
            background: linear-gradient(135deg, #5a5a5a 0%, #4a4a4a 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 102, 102, 0.3);
        }

        /* Item Card Delete Overlay */
        .item-delete-overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2a1810 0%, #1a0f08 100%);
            border: none;
            border-radius: 12px;
            padding: 20px;
            width: 280px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9);
            z-index: 2000;
            backdrop-filter: blur(2px);
        }

        .item-delete-overlay::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            z-index: -1;
        }

        .item-delete-overlay h3 {
            color: #ff6b6b;
            margin-bottom: 12px;
            font-family: 'Times New Roman', serif;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 1.1rem;
        }

        .item-delete-overlay p {
            color: #e0e0e0;
            margin-bottom: 16px;
            font-size: 0.9rem;
            line-height: 1.3;
        }

        /* Spell Card Delete Overlay */
        .spell-delete-overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2a1810 0%, #1a0f08 100%);
            border: none;
            border-radius: 12px;
            padding: 20px;
            width: 280px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.9);
            z-index: 2000;
            backdrop-filter: blur(2px);
        }

        .spell-delete-overlay::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            z-index: -1;
        }

        .spell-delete-overlay h3 {
            color: #ff6b6b;
            margin-bottom: 12px;
            font-family: 'Times New Roman', serif;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 1.1rem;
        }

        .spell-delete-overlay p {
            color: #e0e0e0;
            margin-bottom: 16px;
            font-size: 0.9rem;
            line-height: 1.3;
        }

        /* Card Dealing Animations */
        @keyframes slideFromLeft {
            0% {
                transform: translateX(-400px) scale(0.9);
                opacity: 0;
            }
            100% {
                transform: translateX(0) scale(1);
                opacity: 1;
            }
        }

        /* Reverse animations for deck closing */
        /* Individual card closing animations removed - everything fades together */

        /* Animation classes */
        .item-card.dealing {
            animation: slideFromLeft 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        .spell-card.dealing {
            animation: slideFromLeft 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        /* Initial state for cards before animation */
        .item-card.pre-deal {
            transform: translateX(-400px) scale(0.9);
            opacity: 0;
        }

        .spell-card.pre-deal {
            transform: translateX(-400px) scale(0.9);
            opacity: 0;
        }

        /* All individual card closing animations removed - everything fades together */

        /* Add Enemy Button */
        .add-enemy-btn {
            background: linear-gradient(180deg, #4a1a1a 0%, #2a0a0a 100%);
            color: #e0e0e0;
            border: 2px solid #8b3535;
            border-radius: 6px;
            padding: 8px 16px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .add-enemy-btn:hover {
            background: linear-gradient(180deg, #5a2a2a 0%, #3a1a1a 100%);
            border-color: #a04545;
            transform: translateY(-2px);
        }

        /* Enemy Card Styling */
        .character-card.enemy {
            background: linear-gradient(180deg, #1a0f0f 0%, #0f0505 100%) !important;
            border: none !important;
        }

        .character-card.enemy:hover {
            box-shadow: 0 12px 40px rgba(90, 32, 32, 0.6);
        }

        .character-card.enemy .card-header {
            background: transparent !important;
        }

        .character-card.enemy .header-top-section,
        .character-card.enemy .header-bottom-section {
            background: #2a1010 !important;
        }

        /* Override race-specific gold backgrounds for enemy cards */
        .character-card.enemy.race-human .header-top-section,
        .character-card.enemy.race-dragonborn .header-top-section,
        .character-card.enemy.race-elf .header-top-section,
        .character-card.enemy.race-gnome .header-top-section,
        .character-card.enemy.race-half-elf .header-top-section,
        .character-card.enemy.race-halfling .header-top-section,
        .character-card.enemy.race-dwarf .header-top-section,
        .character-card.enemy.race-tiefling .header-top-section,
        .character-card.enemy.race-half-orc .header-top-section,
        .character-card.enemy.race-aarakocra .header-top-section,
        .character-card.enemy.race-default .header-top-section,
        .character-card.enemy .header-top-section {
            background: #3a1515 !important;
        }

        .character-card.enemy.race-human .header-bottom-section,
        .character-card.enemy.race-dragonborn .header-bottom-section,
        .character-card.enemy.race-elf .header-bottom-section,
        .character-card.enemy.race-gnome .header-bottom-section,
        .character-card.enemy.race-half-elf .header-bottom-section,
        .character-card.enemy.race-halfling .header-bottom-section,
        .character-card.enemy.race-dwarf .header-bottom-section,
        .character-card.enemy.race-tiefling .header-bottom-section,
        .character-card.enemy.race-half-orc .header-bottom-section,
        .character-card.enemy.race-aarakocra .header-bottom-section,
        .character-card.enemy.race-default .header-bottom-section,
        .character-card.enemy .header-bottom-section {
            background: #3a1515 !important;
        }

        .character-card.enemy .ac-inputs {
            background: linear-gradient(135deg, #5a2020 0%, #3a1010 100%) !important;
        }

        /* Make all header text white in enemy cards */
        .character-card.enemy .card-name,
        .character-card.enemy .ability-label,
        .character-card.enemy .header-top-section *,
        .character-card.enemy .header-bottom-section *,
        .character-card.enemy .header-top-section,
        .character-card.enemy .header-bottom-section {
            color: #ffffff !important;
        }

        /* Ensure input fields in enemy headers are also white text */
        .character-card.enemy .header-top-section input,
        .character-card.enemy .header-bottom-section input,
        .character-card.enemy .ability-input {
            color: #ffffff !important;
        }

        .character-card.enemy.dead {
            opacity: 0.6;
            filter: grayscale(50%);
        }



        /* Character Info Section */
        .character-info-section {
            margin-bottom: 12px;
        }

        .info-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .info-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #2c1810;
            min-width: 60px;
        }

        /* Inline Info Row Styling */
        .info-row {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            align-items: center;
        }

        .info-group-inline {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
        }

        .info-label-inline {
            font-size: 0.8rem;
            font-weight: 600;
            color: #2c1810;
            white-space: nowrap;
        }

        .card-class-inline {
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(44, 24, 16, 0.3);
            color: #2c1810;
            font-size: 0.8rem;
            font-weight: 500;
            padding: 2px 4px;
            font-family: 'Times New Roman', serif;
            transition: all 0.2s ease;
            width: 60px;
        }

        .race-input-inline {
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(44, 24, 16, 0.3);
            color: #2c1810;
            font-size: 0.8rem;
            font-weight: 500;
            padding: 2px 4px;
            font-family: 'Times New Roman', serif;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 0;
        }

        .level-input-inline {
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(44, 24, 16, 0.3);
            color: #2c1810;
            font-size: 0.8rem;
            font-weight: 500;
            padding: 2px 4px;
            font-family: 'Times New Roman', serif;
            transition: all 0.2s ease;
            width: 30px;
            text-align: center;
        }

        .level-input-inline::-webkit-outer-spin-button,
        .level-input-inline::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .level-input-inline[type=number] {
            -moz-appearance: textfield;
        }

        .card-class-inline:focus,
        .race-input-inline:focus,
        .level-input-inline:focus {
            outline: none;
            border-bottom: 2px solid #8b7355;
            background: rgba(255, 255, 255, 0.1);
        }

        /* Bio Section */
        .bio-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .bio-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .bio-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #2c1810;
            text-transform: none;
            letter-spacing: normal;
        }

        .bio-textarea {
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 4px 0;
            font-family: 'Times New Roman', serif;
            color: #1a0f08;
            font-size: 0.75rem;
            box-shadow: none;
            resize: vertical;
            min-height: 30px;
        }

        .bio-textarea:focus {
            outline: none;
            background: transparent;
        }

        /* Active Effects Section */
        .active-effects-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 0;
        }

        .active-effects-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .active-effects-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #2c1810;
            text-transform: none;
            letter-spacing: normal;
        }

        .active-effects-textarea {
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 4px 0;
            font-family: 'Times New Roman', serif;
            color: #1a0f08;
            font-size: 0.75rem;
            box-shadow: none;
            resize: vertical;
            min-height: 30px;
        }

        .active-effects-textarea:focus {
            outline: none;
            background: transparent;
        }

        /* Stat highlighting - colored shields */
        .ability-input.highest-stat {
            /* Remove border highlighting */
        }

        .ability-input.lowest-stat {
            /* Remove border highlighting */
        }

        /* Gold shield for highest stat */
        .stat-shield-wrapper.highest-stat {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='107' height='83' viewBox='0 0 107 83' fill='none'%3E%3Cg filter='url(%23filter0_ddii_6_396201)'%3E%3Cpath d='M15.6037 42.7525C15.0682 43.3716 15.1903 44.4322 15.9198 44.8037C23.0544 48.4369 51.9225 63.0908 53.4108 63.0908C54.913 63.0908 84.3066 48.1631 91.0953 44.7052C91.7785 44.3572 91.926 43.406 91.4883 42.7765C90.1543 40.8581 87.9555 36.5611 87.9555 29.0784C87.9555 23.0651 91.5097 14.221 92.9867 10.8053C93.2885 10.1072 92.8329 9.31156 92.0755 9.24168C86.4648 8.72402 66.7766 7.0001 53.4108 7.0001C40.3513 7.0001 21.2556 8.64595 15.1537 9.20425C14.2952 9.28279 13.8465 10.2887 14.3059 11.0181C16.2302 14.0741 19.9988 21.0799 19.9988 29.0784C19.9988 36.53 17.2731 40.8224 15.6037 42.7525Z' fill='url(%23paint0_linear_gold)'/%3E%3C/g%3E%3Cdefs%3E%3Cfilter id='filter0_ddii_6_396201' x='0.903583' y='0.390512' width='105.396' height='82.5288' filterUnits='userSpaceOnUse' color-interpolation-filters='sRGB'%3E%3CfeFlood flood-opacity='0' result='BackgroundImageFix'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dy='6.60949'/%3E%3CfeGaussianBlur stdDeviation='6.60949'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.4 0'/%3E%3CfeBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow_6_396201'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dy='2.20316'/%3E%3CfeGaussianBlur stdDeviation='2.20316'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.65 0'/%3E%3CfeBlend mode='normal' in2='effect1_dropShadow_6_396201' result='effect2_dropShadow_6_396201'/%3E%3CfeBlend mode='normal' in='SourceGraphic' in2='effect2_dropShadow_6_396201' result='shape'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dx='1.10158' dy='-1.10158'/%3E%3CfeGaussianBlur stdDeviation='1.10158'/%3E%3CfeComposite in2='hardAlpha' operator='arithmetic' k2='-1' k3='1'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0.223529 0 0 0 0 0.184314 0 0 0 0 0.145098 0 0 0 0.6 0'/%3E%3CfeBlend mode='normal' in2='shape' result='effect3_innerShadow_6_396201'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dx='-1.10158' dy='1.10158'/%3E%3CfeGaussianBlur stdDeviation='1.10158'/%3E%3CfeComposite in2='hardAlpha' operator='arithmetic' k2='-1' k3='1'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0.882422 0 0 0 0 0.87413 0 0 0 0 0.832671 0 0 0 1 0'/%3E%3CfeBlend mode='normal' in2='effect3_innerShadow_6_396201' result='effect4_innerShadow_6_396201'/%3E%3C/filter%3E%3ClinearGradient id='paint0_linear_gold' x1='53.4108' y1='63.0908' x2='53.4108' y2='7.0001' gradientUnits='userSpaceOnUse'%3E%3Cstop stop-color='%23FEF3C7'/%3E%3Cstop offset='0.385417' stop-color='%23FDE68A'/%3E%3Cstop offset='0.71875' stop-color='%23F59E0B'/%3E%3Cstop offset='1' stop-color='%23D97706'/%3E%3C/linearGradient%3E%3C/defs%3E%3C/svg%3E");
        }

        /* Red shield for lowest stat */
        .stat-shield-wrapper.lowest-stat {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='107' height='83' viewBox='0 0 107 83' fill='none'%3E%3Cg filter='url(%23filter0_ddii_6_396201)'%3E%3Cpath d='M15.6037 42.7525C15.0682 43.3716 15.1903 44.4322 15.9198 44.8037C23.0544 48.4369 51.9225 63.0908 53.4108 63.0908C54.913 63.0908 84.3066 48.1631 91.0953 44.7052C91.7785 44.3572 91.926 43.406 91.4883 42.7765C90.1543 40.8581 87.9555 36.5611 87.9555 29.0784C87.9555 23.0651 91.5097 14.221 92.9867 10.8053C93.2885 10.1072 92.8329 9.31156 92.0755 9.24168C86.4648 8.72402 66.7766 7.0001 53.4108 7.0001C40.3513 7.0001 21.2556 8.64595 15.1537 9.20425C14.2952 9.28279 13.8465 10.2887 14.3059 11.0181C16.2302 14.0741 19.9988 21.0799 19.9988 29.0784C19.9988 36.53 17.2731 40.8224 15.6037 42.7525Z' fill='url(%23paint0_linear_red)'/%3E%3C/g%3E%3Cdefs%3E%3Cfilter id='filter0_ddii_6_396201' x='0.903583' y='0.390512' width='105.396' height='82.5288' filterUnits='userSpaceOnUse' color-interpolation-filters='sRGB'%3E%3CfeFlood flood-opacity='0' result='BackgroundImageFix'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dy='6.60949'/%3E%3CfeGaussianBlur stdDeviation='6.60949'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.4 0'/%3E%3CfeBlend mode='normal' in2='BackgroundImageFix' result='effect1_dropShadow_6_396201'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dy='2.20316'/%3E%3CfeGaussianBlur stdDeviation='2.20316'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.65 0'/%3E%3CfeBlend mode='normal' in2='effect1_dropShadow_6_396201' result='effect2_dropShadow_6_396201'/%3E%3CfeBlend mode='normal' in='SourceGraphic' in2='effect2_dropShadow_6_396201' result='shape'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dx='1.10158' dy='-1.10158'/%3E%3CfeGaussianBlur stdDeviation='1.10158'/%3E%3CfeComposite in2='hardAlpha' operator='arithmetic' k2='-1' k3='1'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0.223529 0 0 0 0 0.184314 0 0 0 0 0.145098 0 0 0 0.6 0'/%3E%3CfeBlend mode='normal' in2='shape' result='effect3_innerShadow_6_396201'/%3E%3CfeColorMatrix in='SourceAlpha' type='matrix' values='0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0' result='hardAlpha'/%3E%3CfeOffset dx='-1.10158' dy='1.10158'/%3E%3CfeGaussianBlur stdDeviation='1.10158'/%3E%3CfeComposite in2='hardAlpha' operator='arithmetic' k2='-1' k3='1'/%3E%3CfeColorMatrix type='matrix' values='0 0 0 0 0.882422 0 0 0 0 0.87413 0 0 0 0 0.832671 0 0 0 1 0'/%3E%3CfeBlend mode='normal' in2='effect3_innerShadow_6_396201' result='effect4_innerShadow_6_396201'/%3E%3C/filter%3E%3ClinearGradient id='paint0_linear_red' x1='53.4108' y1='63.0908' x2='53.4108' y2='7.0001' gradientUnits='userSpaceOnUse'%3E%3Cstop stop-color='%23FECACA'/%3E%3Cstop offset='0.385417' stop-color='%23FCA5A5'/%3E%3Cstop offset='0.71875' stop-color='%23F87171'/%3E%3Cstop offset='1' stop-color='%23EF4444'/%3E%3C/linearGradient%3E%3C/defs%3E%3C/svg%3E");
        }

        /* Death styling */
        .character-card.dead {
            opacity: 0.6;
            filter: grayscale(80%);
            position: relative;
        }

        .character-card.dead::before {
            content: "💀";
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 2rem;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .death-toggle-btn {
            background: linear-gradient(180deg, #dc2626 0%, #b91c1c 100%);
            color: #ffffff;
            border: 1px solid #991b1b;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.6rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.4);
            font-family: 'Times New Roman', serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 0;
        }

        .death-toggle-btn:hover {
            background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%);
            transform: translateY(-1px);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .death-toggle-btn.alive {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #e0e0e0;
            border-color: #8b7355;
            font-size: 0.5rem;
            padding: 3px 6px;
        }

        .death-toggle-btn.alive:hover {
            background: linear-gradient(180deg, #5a5a5a 0%, #4a4a4a 100%);
            color: #ffffff;
        }

        .card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 12px 2px 12px;
        }

        .footer-left {
            display: flex;
            align-items: center;
        }

        .footer-right {
            display: flex;
            align-items: center;
        }

        /* Monster Browser Styles */
        .monster-browser-section {
            margin: 15px auto;
            max-width: 1200px; /* Constrain the width */
        }

        .monster-browser-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 20px;
        }

        .monster-browser-header h2 {
            color: #ffd700;
            font-size: 1.4rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .monster-browser-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .monster-search-input {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #e0e0e0;
            border: 2px solid #8b7355;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.9rem;
            font-family: 'Times New Roman', serif;
            min-width: 200px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .monster-search-input:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                0 0 0 2px rgba(255, 215, 0, 0.3);
        }

        .monster-type-filter {
            background: linear-gradient(180deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #e0e0e0;
            border: 2px solid #8b7355;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.9rem;
            font-family: 'Times New Roman', serif;
            cursor: pointer;
        }

        .monster-browser-container {
            position: relative;
            overflow: hidden;
            border-radius: 8px;
        }

        .monster-browser-container::before,
        .monster-browser-container::after {
            content: '';
            position: absolute;
            top: 0;
            bottom: 0;
            width: 120px; /* Fade width */
            z-index: 10;
            pointer-events: none;
        }

        .monster-browser-container::before {
            left: 0;
            background: linear-gradient(to right, 
                rgba(5, 26, 15, 1) 0%, 
                rgba(5, 26, 15, 0.9) 20%, 
                rgba(5, 26, 15, 0.6) 50%, 
                rgba(5, 26, 15, 0) 100%);
        }

        .monster-browser-container::after {
            right: 0;
            background: linear-gradient(to left, 
                rgba(2, 18, 7, 1) 0%, 
                rgba(2, 18, 7, 0.9) 20%, 
                rgba(2, 18, 7, 0.6) 50%, 
                rgba(2, 18, 7, 0) 100%);
        }

        .monster-browser-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
            scrollbar-color: #8b7355 rgba(139, 115, 85, 0.2);
            scroll-behavior: smooth;
            padding: 15px 0;
        }

        .monster-browser-scroll::-webkit-scrollbar {
            height: 8px;
        }

        .monster-browser-scroll::-webkit-scrollbar-track {
            background: rgba(139, 115, 85, 0.2);
            border-radius: 4px;
        }

        .monster-browser-scroll::-webkit-scrollbar-thumb {
            background: #8b7355;
            border-radius: 4px;
        }

        .monster-browser-scroll::-webkit-scrollbar-thumb:hover {
            background: #a0522d;
        }

        .monster-browser-content {
            display: flex;
            gap: 12px;
            padding: 0 15px;
            min-height: 200px;
        }

        .monster-card-mini {
            flex: 0 0 auto;
            width: 180px; /* Increased from 140px */
            background: linear-gradient(180deg, #1a0f0f 0%, #0f0505 100%);
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 4px 8px rgba(0, 0, 0, 0.4);
        }

        .monster-card-mini:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                0 12px 40px rgba(90, 32, 32, 0.6);
        }

        .monster-card-mini-image {
            width: 100%;
            height: 150px; /* Increased from 120px */
            background: #1a1a1a;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: relative;
            overflow: hidden;
        }

        .monster-card-mini-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, transparent 0%, rgba(0, 0, 0, 0.7) 100%);
        }

        .monster-card-mini-image.loading {
            background: linear-gradient(45deg, #2a2a2a 25%, #3a3a3a 25%, #3a3a3a 50%, #2a2a2a 50%, #2a2a2a 75%, #3a3a3a 75%);
            background-size: 20px 20px;
            animation: loading-stripe 1s linear infinite;
        }

        @keyframes loading-stripe {
            0% { background-position: 0 0; }
            100% { background-position: 20px 0; }
        }

        .monster-card-mini-content {
            padding: 12px;
            text-align: center;
        }

        .monster-card-mini-name {
            color: #e0e0e0;
            font-size: 0.95rem; /* Increased from 0.85rem */
            font-weight: bold;
            margin-bottom: 8px;
            line-height: 1.2;
            height: 2.4em;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .monster-card-mini-add {
            background: linear-gradient(180deg, #6b4444 0%, #4a2a2a 100%);
            color: #d4af8c;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.75rem;
            font-family: 'Times New Roman', serif;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .monster-card-mini-add:hover {
            background: linear-gradient(180deg, #7a5555 0%, #5a3a3a 100%);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .monster-browser-nav {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            transform: translateY(-50%);
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            padding: 0 5px;
        }

        .monster-nav-btn {
            background: rgba(0, 0, 0, 0.7);
            color: #ffd700;
            border: 2px solid #8b7355;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .monster-nav-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: #ffd700;
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.6);
        }

        .monster-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        /* Loading skeleton */
        .monster-skeleton {
            flex: 0 0 auto;
            width: 140px;
            height: 200px;
            background: linear-gradient(90deg, #2a2a2a 25%, #3a3a3a 50%, #2a2a2a 75%);
            background-size: 200% 100%;
            animation: skeleton-loading 1.5s infinite;
            border-radius: 8px;
        }

        @keyframes skeleton-loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Monster browser loading and error states */
        .monster-loading, .monster-error {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #e0e0e0;
            font-size: 1rem;
            text-align: center;
            padding: 20px;
        }

        .monster-error {
            color: #ff6b6b;
        }

        /* Spell loading spinner */
        .spell-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            width: 100%;
            color: #e0e0e0;
            font-size: 1rem;
            text-align: center;
            padding: 20px;
            position: absolute;
            top: 0;
            left: 0;
            background: rgba(4, 14, 8, 0.8);
            border-radius: 8px;
        }

        .spell-loading-spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(157, 78, 221, 0.3);
            border-top: 3px solid #9d4edd;
            border-radius: 50%;
            animation: spell-spinner-rotate 1s linear infinite;
        }

        @keyframes spell-spinner-rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Guild Login Screen -->
    <div id="guildLoginScreen" class="guild-login-screen">
        <div class="guild-login-form">
                                <h2 style="font-family: 'Times New Roman', serif; font-style: italic; font-size: 1.1rem; font-weight: normal; color: #ffd700; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8); text-transform: none;">Speak Friend and Enter</h2>
            <div id="guildNameDisplay" class="guild-name-display"></div>
            <div class="form-group">
                <label for="guildPassword">Guild Password</label>
                <input type="password" id="guildPassword" placeholder="Enter guild password">
            </div>
            <button class="login-btn" onclick="loginToGuild()">Access Guild</button>
            <div id="guildLoginMessage"></div>
        </div>
    </div>

    <div class="app" id="mainApp" style="display: none;">
        <header class="app-header">
            <div class="header-left">
                <h1>Guild Hub 1.0</h1>
                <div id="connectionStatus" class="connection-status">
                    🔴 Disconnected
                </div>
            </div>
            <div class="header-controls">
                <div id="currentGuildInfo" class="current-guild-info"></div>
                <div class="campaign-selector-container">
                    <select id="campaignSelector" class="campaign-selector" onchange="switchCampaign(this.value)">
                        <option value="">Loading campaigns...</option>
                    </select>
                    <button class="new-campaign-btn" onclick="showNewCampaignModal()">
                        + New Campaign
                    </button>
                </div>
                <button class="add-character-btn" onclick="addCharacter()">
                    + Add Character
                </button>
            </div>
        </header>
        
        <main class="app-main">
            <!-- Character Section -->
            <div class="character-section">
                <div class="character-section-header">
                    <h2>Character Deck</h2>
                </div>
                <div class="character-deck" id="characterDeck">
                    <!-- Character cards will be added here -->
                </div>
            </div>

            <!-- Enemy Deck Section -->
            <div class="character-section">
                <div class="character-section-header">
                    <h2>Enemy Deck</h2>
                </div>
                <div class="character-deck" id="enemyDeck">
                    <!-- Enemy cards will be added here -->
                </div>
            </div>

            <!-- Monster Browser Section -->
            <div class="monster-browser-section">
                <div class="monster-browser-header">
                    <h2>Monster Library</h2>
                    <div class="monster-browser-controls">
                        <input type="text" id="monsterSearchInput" class="monster-search-input" placeholder="Search monsters..." onkeyup="filterMonsters(this.value)">
                        <select id="monsterTypeFilter" class="monster-type-filter" onchange="filterMonstersByType(this.value)">
                            <option value="">All Types</option>
                            <option value="aberration">Aberration</option>
                            <option value="beast">Beast</option>
                            <option value="celestial">Celestial</option>
                            <option value="construct">Construct</option>
                            <option value="dragon">Dragon</option>
                            <option value="elemental">Elemental</option>
                            <option value="fey">Fey</option>
                            <option value="fiend">Fiend</option>
                            <option value="giant">Giant</option>
                            <option value="humanoid">Humanoid</option>
                            <option value="monstrosity">Monstrosity</option>
                            <option value="ooze">Ooze</option>
                            <option value="plant">Plant</option>
                            <option value="undead">Undead</option>
                        </select>
                        <button class="add-enemy-btn" onclick="addEnemy()">+ Add Custom Enemy</button>
                    </div>
                </div>
                <div class="monster-browser-container">
                    <div class="monster-browser-scroll" id="monsterBrowserScroll">
                        <div class="monster-browser-content" id="monsterBrowserContent">
                            <!-- Monster cards will be dynamically loaded here -->
                        </div>
                    </div>
                    <div class="monster-browser-nav">
                        <button class="monster-nav-btn" id="monsterNavLeft" onclick="scrollMonsterBrowser(-1)">‹</button>
                        <button class="monster-nav-btn" id="monsterNavRight" onclick="scrollMonsterBrowser(1)">›</button>
                    </div>
                </div>
            </div>

            <!-- Our Story Section -->
            <div class="our-story-section" id="ourStorySection">
                <div class="our-story-header">
                    <h2>Our Story</h2>
                </div>
                <div class="our-story-content">
                    <div class="story-text-area">
                        <textarea id="ourStoryText" placeholder="Tell the story of your campaign... the world, the characters, the adventures that await..."></textarea>
                    </div>
                    <div class="story-image-placeholder">
                        <div class="image-placeholder">
                            <span>📷</span>
                            <p>Campaign Image</p>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Campaign Info Edit Modal -->
    <div id="campaignInfoModal" class="campaign-modal">
        <div class="campaign-modal-content">
            <div class="campaign-modal-header">
                <h3>Edit Campaign Information</h3>
                <button class="close-modal-btn" onclick="closeCampaignInfoModal()">✕</button>
            </div>
            <div class="campaign-modal-body">
                <div class="form-group">
                    <label for="campaignBackstory">Backstory</label>
                    <textarea id="campaignBackstory" placeholder="Enter the campaign's backstory and lore..."></textarea>
                </div>
                <div class="form-group">
                    <label for="campaignWorld">World & Environment</label>
                    <textarea id="campaignWorld" placeholder="Describe the world, geography, and environment..."></textarea>
                </div>
                <div class="form-group">
                    <label for="campaignPolitics">Political Considerations</label>
                    <textarea id="campaignPolitics" placeholder="Describe political factions, governments, and power structures..."></textarea>
                </div>
                <div class="form-group">
                    <label for="campaignReligion">Religion & Culture</label>
                    <textarea id="campaignReligion" placeholder="Describe religious beliefs, cultural practices, and traditions..."></textarea>
                </div>
                <div class="form-group">
                    <label for="campaignMagic">Magic & Technology</label>
                    <textarea id="campaignMagic" placeholder="Describe magic systems, technology level, and special rules..."></textarea>
                </div>
                <div class="form-group">
                    <label for="campaignNotes">Additional Notes</label>
                    <textarea id="campaignNotes" placeholder="Any other important campaign information..."></textarea>
                </div>
                <div class="campaign-modal-actions">
                    <button class="cancel-btn" onclick="closeCampaignInfoModal()">Cancel</button>
                    <button class="create-campaign-btn" onclick="saveCampaignInfo()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Campaign Modal -->
    <div id="campaignModal" class="campaign-modal">
        <div class="campaign-modal-content">
            <div class="campaign-modal-header">
                <h3>Create New Campaign</h3>
                <button class="close-modal-btn" onclick="closeCampaignModal()">✕</button>
            </div>
            <div class="campaign-modal-body">
                <div class="form-group">
                    <label for="campaignName">Campaign Name</label>
                    <input type="text" id="campaignName" placeholder="Enter campaign name">
                </div>
                <div class="form-group">
                    <label for="campaignDescription">Description (Optional)</label>
                    <textarea id="campaignDescription" placeholder="Enter campaign description"></textarea>
                </div>
                <div class="campaign-modal-actions">
                    <button class="cancel-btn" onclick="closeCampaignModal()">Cancel</button>
                    <button class="create-campaign-btn" onclick="createCampaign()">Create Campaign</button>
                </div>
            </div>
        </div>
    </div>



    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-database-compat.js"></script>

    <script>
        // Firebase configuration (single project for all guilds)
        const firebaseConfig = {
            apiKey: "AIzaSyBhYLrZ9g901o1ZA35OpQ4YBz_YFpaOPQk",
            authDomain: "dndcards.firebaseapp.com",
            databaseURL: "https://dndcards-default-rtdb.firebaseio.com",
            projectId: "dndcards",
            storageBucket: "dndcards.firebasestorage.app",
            messagingSenderId: "821071296173",
            appId: "1:821071296173:web:a0e5db9c9d5323de607824",
            measurementId: "G-HY29MSXDCP"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // Multi-tenant guild system with campaigns
        let currentGuildId = null;
        let currentGuildData = null;
        let currentCampaignId = null;
        let campaigns = [];
        let characters = [];
        let enemies = [];
        let isConnected = false;
        let isAuthenticated = false;
        let activeTabs = {}; // Track active tab for each character

        // Get guild ID from URL
        function getGuildId() {
            // Try URL parameters first (works with file:// URLs)
            const urlParams = new URLSearchParams(window.location.search);
            const guildParam = urlParams.get('guild');
            if (guildParam) {
                return guildParam;
            }
            
            // Fallback to path-based routing (works with web servers)
            const path = window.location.pathname;
            const guildId = path.split('/')[1];
            if (guildId) {
                return guildId;
            }
            
            // Default to demo guild
            return 'demo';
        }

        // Get guild-specific database path
        function getGuildPath() {
            const guildId = getGuildId();
            return `guilds/${guildId}`;
        }

        // Get campaign-specific database path
        function getCampaignPath() {
            const guildId = getGuildId();
            const campaignId = currentCampaignId || 'default';
            return `guilds/${guildId}/campaigns/${campaignId}`;
        }

        // Update page title and header with guild info
        function updateGuildDisplay() {
            if (!currentGuildData) return;
            
            const guildName = currentGuildData.name;
            document.title = `${guildName} - Guild Hub 1.0`;
            
            const header = document.querySelector('.app-header h1');
            if (header) {
                header.textContent = `${guildName} - Guild Hub 1.0`;
            }
            
            // Update current guild info display
            const guildInfo = document.getElementById('currentGuildInfo');
            if (guildInfo) {
                guildInfo.textContent = guildName;
            }
        }

        // Login to guild
        function loginToGuild() {
            const password = document.getElementById('guildPassword').value;
            const guildId = getGuildId();
            const messageDiv = document.getElementById('guildLoginMessage');
            
            if (!password.trim()) {
                messageDiv.innerHTML = '<div class="status-message status-error">Please enter the guild password!</div>';
                return;
            }
            
            // Check guild credentials in admin database
            database.ref(`admin/guilds/${guildId}`).once('value')
                .then((snapshot) => {
                    if (!snapshot.exists()) {
                        messageDiv.innerHTML = '<div class="status-message status-error">Guild not found!</div>';
                        return;
                    }
                    
                    const guildData = snapshot.val();
                    if (guildData.password === password) {
                        // Authentication successful
                        isAuthenticated = true;
                        currentGuildId = guildId;
                        currentGuildData = guildData;
                        
                        // Hide login screen and show main app
                        document.getElementById('guildLoginScreen').style.display = 'none';
                        document.getElementById('mainApp').style.display = 'block';
                        
                        // Initialize the app
                        updateGuildDisplay();
                        loadCampaigns();
                        // Campaign info will be loaded when campaigns are loaded
                        
                        messageDiv.innerHTML = '';
                    } else {
                        messageDiv.innerHTML = '<div class="status-message status-error">Invalid password!</div>';
                    }
                })
                .catch((error) => {
                    messageDiv.innerHTML = '<div class="status-message status-error">Error: ' + error.message + '</div>';
                });
        }

        // Check if user is already authenticated for this guild
        function checkGuildAccess() {
            const guildId = getGuildId();
            
            // Check if guild exists
            database.ref(`admin/guilds/${guildId}`).once('value')
                .then((snapshot) => {
                    if (!snapshot.exists()) {
                        document.getElementById('guildLoginMessage').innerHTML = 
                            '<div class="status-message status-error">Guild not found! Please check the URL.</div>';
                        return;
                    }
                    
                    // Guild exists, show login screen with guild name
                    const guildData = snapshot.val();
                    const guildNameDisplay = document.getElementById('guildNameDisplay');
                    guildNameDisplay.textContent = guildData.name;
                    
                    document.getElementById('guildLoginScreen').style.display = 'flex';
                    document.getElementById('mainApp').style.display = 'none';
                })
                .catch((error) => {
                    document.getElementById('guildLoginMessage').innerHTML = 
                        '<div class="status-message status-error">Error: ' + error.message + '</div>';
                });
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            checkGuildAccess();
        });

        // Handle Enter key in password field
        document.getElementById('guildPassword').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                loginToGuild();
            }
        });

        // Handle Enter key in campaign name field
        document.getElementById('campaignName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                createCampaign();
            }
        });

        // Handle Escape key to close modals
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeCampaignModal();
                closeCampaignInfoModal();
            }
        });

        // Campaign Management Functions
        function loadCampaigns() {
            const guildPath = getGuildPath();
            database.ref(`${guildPath}/campaigns`).on('value', (snapshot) => {
                campaigns = [];
                if (snapshot.exists()) {
                    snapshot.forEach((childSnapshot) => {
                        campaigns.push({
                            id: childSnapshot.key,
                            ...childSnapshot.val()
                        });
                    });
                }
                
                // If no campaigns exist, create a default one
                if (campaigns.length === 0) {
                    createDefaultCampaign();
                } else {
                    renderCampaignSelector();
                    // Set current campaign to first one if none selected
                    if (!currentCampaignId) {
                        switchCampaign(campaigns[0].id);
                    } else {
                        // Load campaign info and banner for current campaign
                        loadCampaignInfo();
                        loadCampaignBanner();
                    }
                }
            });
        }

        function createDefaultCampaign() {
            const defaultCampaign = {
                name: 'Main Campaign',
                description: 'Your primary campaign',
                createdDate: new Date().toISOString(),
                lastUpdated: Date.now()
            };
            
            const guildPath = getGuildPath();
            database.ref(`${guildPath}/campaigns/default`).set(defaultCampaign)
                .then(() => {
                    // Create placeholder characters for the default campaign
                    return createPlaceholderCharactersForCampaign(guildPath, 'default');
                })
                .then(() => {
                    currentCampaignId = 'default';
                    loadCampaigns();
                });
        }

        function renderCampaignSelector() {
            const selector = document.getElementById('campaignSelector');
            selector.innerHTML = '';
            
            campaigns.forEach(campaign => {
                const option = document.createElement('option');
                option.value = campaign.id;
                option.textContent = campaign.name;
                if (campaign.id === currentCampaignId) {
                    option.selected = true;
                }
                selector.appendChild(option);
            });
        }

        function switchCampaign(campaignId) {
            if (campaignId === currentCampaignId) return;
            
            console.log(`Switching from campaign ${currentCampaignId} to campaign ${campaignId}`);
            
            // Clear current data
            characters = [];
            enemies = [];
            renderCharacters();
            renderEnemies();
            
            // Update current campaign
            currentCampaignId = campaignId;
            
            // Reload characters and campaign info for new campaign
            setupRealtimeListener();
            setupMessageListener();
            loadCampaignInfo();
            loadCampaignBanner();
        }

        function showNewCampaignModal() {
            document.getElementById('campaignModal').style.display = 'block';
            document.getElementById('campaignName').focus();
        }

        function closeCampaignModal() {
            document.getElementById('campaignModal').style.display = 'none';
            document.getElementById('campaignName').value = '';
            document.getElementById('campaignDescription').value = '';
        }

        function createCampaign() {
            const name = document.getElementById('campaignName').value.trim();
            const description = document.getElementById('campaignDescription').value.trim();
            
            if (!name) {
                alert('Please enter a campaign name');
                return;
            }
            
            const newCampaign = {
                name: name,
                description: description,
                createdDate: new Date().toISOString(),
                lastUpdated: Date.now()
            };
            
            const guildPath = getGuildPath();
            const campaignId = name.toLowerCase().replace(/[^a-z0-9]/g, '') + '_' + Date.now();
            
            database.ref(`${guildPath}/campaigns/${campaignId}`).set(newCampaign)
                .then(() => {
                    // Create placeholder characters for the new campaign
                    return createPlaceholderCharactersForCampaign(guildPath, campaignId);
                })
                .then(() => {
                    closeCampaignModal();
                    // Switch to the new campaign
                    switchCampaign(campaignId);
                })
                .catch((error) => {
                    alert('Error creating campaign: ' + error.message);
                });
        }

        // Create placeholder characters for a new campaign
        function createPlaceholderCharactersForCampaign(guildPath, campaignId) {
            const characters = generatePlaceholderCharacters();
            const promises = characters.map(character => {
                return database.ref(`${guildPath}/campaigns/${campaignId}/characters`).push(character);
            });
            return Promise.all(promises);
        }

        // Generate 3 random placeholder characters
        function generatePlaceholderCharacters() {
            const fantasyNames = [
                'Aria Stormwind', 'Thorin Ironfist', 'Luna Shadowmoon', 'Gareth Brightblade', 'Zara Fireheart',
                'Marcus Stormcaller', 'Elara Nightwhisper', 'Ragnar Frostbeard', 'Seraphina Lightweaver', 'Kael Darkforge',
                'Isabella Moonstone', 'Drakon Bloodfist', 'Lyra Silverwing', 'Magnus Thunderfist', 'Nyx Voidwalker',
                'Valeria Sunseeker', 'Grimtooth Skullcrusher', 'Aurora Frostwind', 'Talon Swiftblade', 'Mystra Spellweaver'
            ];

            const classes = ['Fighter', 'Wizard', 'Rogue', 'Cleric', 'Ranger', 'Paladin', 'Bard', 'Druid', 'Monk', 'Warlock'];
            const races = ['Human', 'Elf', 'Dwarf', 'Halfling', 'Dragonborn', 'Tiefling', 'Half-Orc', 'Gnome', 'Half-Elf', 'Aarakocra'];

            const characters = [];
            
            for (let i = 0; i < 3; i++) {
                const name = fantasyNames[Math.floor(Math.random() * fantasyNames.length)];
                const characterClass = classes[Math.floor(Math.random() * classes.length)];
                const race = races[Math.floor(Math.random() * races.length)];
                const level = Math.floor(Math.random() * 10) + 1; // Level 1-10
                
                // Generate random stats (8-18 range)
                const strength = Math.floor(Math.random() * 11) + 8;
                const dexterity = Math.floor(Math.random() * 11) + 8;
                const constitution = Math.floor(Math.random() * 11) + 8;
                const intelligence = Math.floor(Math.random() * 11) + 8;
                const wisdom = Math.floor(Math.random() * 11) + 8;
                const charisma = Math.floor(Math.random() * 11) + 8;
                
                // Calculate HP based on class and constitution
                const baseHP = characterClass === 'Fighter' ? 10 : 8;
                const hp = baseHP + Math.floor((constitution - 10) / 2);
                
                // Calculate AC based on dexterity
                const ac = 10 + Math.floor((dexterity - 10) / 2);
                
                const character = {
                    name: name,
                    class: characterClass,
                    level: level,
                    race: race,
                    hp: Math.max(1, hp),
                    ac: Math.max(10, ac),
                    strength: strength,
                    dexterity: dexterity,
                    constitution: constitution,
                    intelligence: intelligence,
                    wisdom: wisdom,
                    charisma: charisma,
                    isDead: false,
                    lastUpdated: Date.now(),
                    // Add some placeholder content for other fields
                    background: `A ${race.toLowerCase()} ${characterClass.toLowerCase()} with a mysterious past.`,
                    personality: 'Brave and determined, always ready for adventure.',
                    goals: 'To become a legendary hero and protect the realm.',
                    weapon: 'Standard weapon',
                    armor: 'Basic armor',
                    items: 'Adventuring gear, rations, waterskin',
                    activeEffects: 'None currently',
                    ability1: 'Class ability - varies by character',
                    ability2: 'Racial trait - varies by character',
                    ability3: 'Background feature - varies by character',
                    ultimate: 'Signature move or spell - to be developed'
                };
                
                characters.push(character);
            }
            
            return characters;
        }

        // Campaign Info Management Functions
        function loadCampaignInfo() {
            const campaignPath = getCampaignPath();
            database.ref(`${campaignPath}/info`).once('value')
                .then((snapshot) => {
                    const info = snapshot.val() || {};
                    renderCampaignInfo(info);
                })
                .catch((error) => {
                    console.error('Error loading campaign info:', error);
                    renderCampaignInfo({});
                });
        }

        function renderCampaignInfo(info) {
            const content = document.getElementById('campaignInfoContent');
            
            if (!content) return;
            
            content.innerHTML = `
                <div class="campaign-info-grid">
                    <div class="campaign-info-card">
                        <h3>Backstory</h3>
                        <div class="campaign-info-text ${!info.backstory ? 'empty' : ''}">
                            ${info.backstory || 'No backstory added yet. Click Edit to add campaign lore and history.'}
                        </div>
                    </div>
                    <div class="campaign-info-card">
                        <h3>World & Environment</h3>
                        <div class="campaign-info-text ${!info.world ? 'empty' : ''}">
                            ${info.world || 'No world information added yet. Click Edit to describe the setting and geography.'}
                        </div>
                    </div>
                    <div class="campaign-info-card">
                        <h3>Political Considerations</h3>
                        <div class="campaign-info-text ${!info.politics ? 'empty' : ''}">
                            ${info.politics || 'No political information added yet. Click Edit to describe factions and power structures.'}
                        </div>
                    </div>
                    <div class="campaign-info-card">
                        <h3>Religion & Culture</h3>
                        <div class="campaign-info-text ${!info.religion ? 'empty' : ''}">
                            ${info.religion || 'No religious information added yet. Click Edit to describe beliefs and cultural practices.'}
                        </div>
                    </div>
                    <div class="campaign-info-card">
                        <h3>Magic & Technology</h3>
                        <div class="campaign-info-text ${!info.magic ? 'empty' : ''}">
                            ${info.magic || 'No magic information added yet. Click Edit to describe magic systems and technology.'}
                        </div>
                    </div>
                    <div class="campaign-info-card">
                        <h3>Additional Notes</h3>
                        <div class="campaign-info-text ${!info.notes ? 'empty' : ''}">
                            ${info.notes || 'No additional notes added yet. Click Edit to add any other important campaign information.'}
                        </div>
                    </div>
                </div>
            `;
        }

        function toggleCampaignInfoEdit() {
            const campaignPath = getCampaignPath();
            database.ref(`${campaignPath}/info`).once('value')
                .then((snapshot) => {
                    const info = snapshot.val() || {};
                    
                    // Populate the form
                    document.getElementById('campaignBackstory').value = info.backstory || '';
                    document.getElementById('campaignWorld').value = info.world || '';
                    document.getElementById('campaignPolitics').value = info.politics || '';
                    document.getElementById('campaignReligion').value = info.religion || '';
                    document.getElementById('campaignMagic').value = info.magic || '';
                    document.getElementById('campaignNotes').value = info.notes || '';
                    
                    // Show the modal
                    document.getElementById('campaignInfoModal').style.display = 'block';
                })
                .catch((error) => {
                    console.error('Error loading campaign info for editing:', error);
                    document.getElementById('campaignInfoModal').style.display = 'block';
                });
        }

        function closeCampaignInfoModal() {
            document.getElementById('campaignInfoModal').style.display = 'none';
        }

        function saveCampaignInfo() {
            const campaignPath = getCampaignPath();
            const info = {
                backstory: document.getElementById('campaignBackstory').value.trim(),
                world: document.getElementById('campaignWorld').value.trim(),
                politics: document.getElementById('campaignPolitics').value.trim(),
                religion: document.getElementById('campaignReligion').value.trim(),
                magic: document.getElementById('campaignMagic').value.trim(),
                notes: document.getElementById('campaignNotes').value.trim(),
                lastUpdated: Date.now()
            };
            
            database.ref(`${campaignPath}/info`).set(info)
                .then(() => {
                    closeCampaignInfoModal();
                    loadCampaignInfo();
                })
                .catch((error) => {
                    alert('Error saving campaign info: ' + error.message);
                });
        }

        // Campaign Banner Functions
        function loadCampaignBanner() {
            const campaignPath = getCampaignPath();
            database.ref(`${campaignPath}/banner`).once('value')
                .then((snapshot) => {
                    const bannerData = snapshot.val();
                    if (bannerData && bannerData.imageUrl) {
                        renderCampaignBanner(bannerData.imageUrl, bannerData.campaignName);
                    } else {
                        renderCampaignBanner(null, getCurrentCampaignName());
                    }
                })
                .catch((error) => {
                    console.error('Error loading campaign banner:', error);
                    renderCampaignBanner(null, getCurrentCampaignName());
                });
        }

        function getCurrentCampaignName() {
            const currentCampaign = campaigns.find(c => c.id === currentCampaignId);
            return currentCampaign ? currentCampaign.name : 'Campaign';
        }

        function renderCampaignBanner(imageUrl, campaignName) {
            const banner = document.getElementById('campaignBanner');
            const title = document.getElementById('campaignBannerTitle');
            const generateBtn = document.getElementById('generateBannerBtn');
            const regenerateBtn = document.getElementById('regenerateBannerBtn');

            if (title) {
                title.textContent = campaignName;
            }

            if (imageUrl) {
                if (banner) {
                    banner.style.backgroundImage = `url(${imageUrl})`;
                    banner.classList.add('has-image');
                }
                if (generateBtn) generateBtn.style.display = 'none';
                if (regenerateBtn) regenerateBtn.style.display = 'block';
            } else {
                if (banner) {
                    banner.style.backgroundImage = 'none';
                    banner.classList.remove('has-image');
                }
                if (generateBtn) generateBtn.style.display = 'block';
                if (regenerateBtn) regenerateBtn.style.display = 'none';
            }
        }

        function generateCampaignBanner() {
            console.log('generateCampaignBanner called');
            const campaignPath = getCampaignPath();
            console.log('Campaign path:', campaignPath);
            
            // Get world description for AI prompt
            database.ref(`${campaignPath}/info`).once('value')
                .then((snapshot) => {
                    console.log('Campaign info snapshot:', snapshot.val());
                    const info = snapshot.val() || {};
                    const worldDescription = info.world || '';
                    const campaignName = getCurrentCampaignName();
                    
                    console.log('World description:', worldDescription);
                    console.log('Campaign name:', campaignName);
                    
                    if (!worldDescription.trim()) {
                        alert('Please add some world description first to generate a banner!');
                        return;
                    }
                    
                    generateBannerWithAI(worldDescription, campaignName, campaignPath);
                })
                .catch((error) => {
                    console.error('Error getting campaign info:', error);
                    alert('Error getting campaign information');
                });
        }

        function regenerateCampaignBanner() {
            generateCampaignBanner();
        }

        function generateBannerWithAI(worldDescription, campaignName, campaignPath) {
            console.log('generateBannerWithAI called');
            console.log('World description:', worldDescription);
            console.log('Campaign name:', campaignName);
            console.log('Campaign path:', campaignPath);
            
            const generateBtn = document.getElementById('generateBannerBtn');
            const regenerateBtn = document.getElementById('regenerateBannerBtn');
            
            // Show loading state
            generateBtn.classList.add('loading');
            generateBtn.textContent = '🎨 Generating...';
            regenerateBtn.classList.add('loading');
            regenerateBtn.textContent = '🔄 Generating...';

            // Create AI prompt
            const prompt = `Create a fantasy landscape banner image for a D&D campaign called "${campaignName}". ${worldDescription}. Style: epic fantasy landscape, dramatic lighting, suitable for a banner, 16:9 aspect ratio, high quality, digital art.`;
            console.log('Generated prompt:', prompt);

            // Use a free AI image generation service (example with Unsplash API for placeholder)
            // In a real implementation, you'd use OpenAI DALL-E, Stable Diffusion, or similar
            generatePlaceholderBanner(prompt, campaignName, campaignPath);
        }

        function generatePlaceholderBanner(prompt, campaignName, campaignPath) {
            console.log('generatePlaceholderBanner called');
            console.log('Prompt:', prompt);
            console.log('Campaign name:', campaignName);
            console.log('Campaign path:', campaignPath);
            
            // For now, we'll use a placeholder service
            // In production, you'd integrate with a real AI image generation API
            
            // Simulate API call delay
            setTimeout(() => {
                console.log('Generating image URL...');
                // Use a placeholder image service that generates based on text
                const encodedPrompt = encodeURIComponent(prompt);
                const imageUrl = `https://source.unsplash.com/1600x900/?fantasy,landscape,${encodedPrompt}`;
                console.log('Generated image URL:', imageUrl);
                
                // Save banner data to database
                const bannerData = {
                    imageUrl: imageUrl,
                    campaignName: campaignName,
                    prompt: prompt,
                    generatedAt: Date.now()
                };
                console.log('Banner data to save:', bannerData);
                
                database.ref(`${campaignPath}/banner`).set(bannerData)
                    .then(() => {
                        console.log('Banner saved successfully');
                        renderCampaignBanner(imageUrl, campaignName);
                        resetBannerButtons();
                    })
                    .catch((error) => {
                        console.error('Error saving banner:', error);
                        alert('Error saving banner data');
                        resetBannerButtons();
                    });
            }, 2000); // Simulate 2-second generation time
        }

        function resetBannerButtons() {
            const generateBtn = document.getElementById('generateBannerBtn');
            const regenerateBtn = document.getElementById('regenerateBannerBtn');
            
            generateBtn.classList.remove('loading');
            generateBtn.textContent = '🎨 Generate Banner';
            regenerateBtn.classList.remove('loading');
            regenerateBtn.textContent = '🔄 Regenerate';
        }

        // Dice Roller Popup Functions
        let currentDiceType = 'd4';
        let currentQuantity = 1;
        let currentModifier = 0;
        let lastRollResult = '';
        let rollHistory = [];

        function toggleDiceRoller() {
            const popup = document.getElementById('diceRollerPopup');
            if (popup.style.display === 'block') {
                popup.style.display = 'none';
            } else {
                popup.style.display = 'block';
                updateDiceDisplayPopup();
            }
        }

        function updateDiceDisplayPopup() {
            const container = document.getElementById('diceContainerPopup');
            container.innerHTML = '';
            
            for (let i = 0; i < currentQuantity; i++) {
                const dice = document.createElement('div');
                dice.className = `dice-popup ${currentDiceType}`;
                dice.textContent = '?';
                dice.onclick = () => rollSingleDicePopup(dice);
                container.appendChild(dice);
            }
        }

        function rollSingleDicePopup(diceElement) {
            const result = rollDiceType(currentDiceType);
            diceElement.classList.add('rolling');
            diceElement.textContent = '?';
            
            setTimeout(() => {
                diceElement.classList.remove('rolling');
                diceElement.textContent = result;
                updateRollResultPopup(`${result} (1${currentDiceType})`);
                addToHistoryPopup([result], result, result);
            }, 800);
        }

        function rollDicePopup() {
            const diceElements = document.querySelectorAll('.dice-popup');
            const rollBtn = document.getElementById('rollDiceBtnPopup');
            
            rollBtn.disabled = true;
            rollBtn.textContent = '🎲 Rolling...';
            
            const results = [];
            let total = 0;
            
            // Roll each dice with animation
            diceElements.forEach((dice, index) => {
                setTimeout(() => {
                    const result = rollDiceType(currentDiceType);
                    results.push(result);
                    total += result;
                    
                    dice.classList.add('rolling');
                    dice.textContent = '?';
                    
                    setTimeout(() => {
                        dice.classList.remove('rolling');
                        dice.textContent = result;
                        
                        // Check if all dice have been rolled
                        if (results.length === currentQuantity) {
                            const finalTotal = total + currentModifier;
                            const modifierText = currentModifier !== 0 ? ` + ${currentModifier}` : '';
                            const resultsText = results.length > 1 ? `[${results.join(', ')}]` : results[0];
                            
                            updateRollResultPopup(`${finalTotal} (${currentQuantity}${currentDiceType}${modifierText} = ${resultsText}${modifierText})`);
                            addToHistoryPopup(results, total, finalTotal);
                            rollBtn.disabled = false;
                            rollBtn.textContent = '🎲 ROLL';
                        }
                    }, 1200);
                }, index * 200); // Staggered rolls
            });
        }

        function rollDiceType(diceType) {
            const maxValue = parseInt(diceType.substring(1));
            return Math.floor(Math.random() * maxValue) + 1;
        }

        function updateRollResultPopup(result) {
            const resultElement = document.getElementById('rollResultPopup');
            resultElement.textContent = result;
            lastRollResult = result;
        }

        function addToHistoryPopup(results, subtotal, total) {
            const timestamp = new Date().toLocaleTimeString();
            const historyItem = {
                timestamp,
                diceType: currentDiceType,
                quantity: currentQuantity,
                modifier: currentModifier,
                results,
                subtotal,
                total
            };
            
            rollHistory.unshift(historyItem);
            if (rollHistory.length > 8) {
                rollHistory.pop(); // Keep only last 8 rolls for compact popup
            }
            
            updateHistoryDisplayPopup();
        }

        function updateHistoryDisplayPopup() {
            const historyList = document.getElementById('historyListPopup');
            historyList.innerHTML = '';
            
            rollHistory.forEach(item => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item-popup';
                
                const modifierText = item.modifier !== 0 ? ` + ${item.modifier}` : '';
                const resultsText = item.results.length > 1 ? `[${item.results.join(', ')}]` : item.results[0];
                
                historyItem.innerHTML = `
                    <span class="roll-result">${item.total}</span> 
                    (${item.quantity}${item.diceType}${modifierText} = ${resultsText}${modifierText})
                    <br><small>${item.timestamp}</small>
                `;
                
                historyList.appendChild(historyItem);
            });
        }

        // Dice type selection for popup version
        document.addEventListener('DOMContentLoaded', function() {
            const diceTypeButtons = document.querySelectorAll('.dice-type-btn-popup');
            diceTypeButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    diceTypeButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentDiceType = this.getAttribute('data-dice');
                    updateDiceDisplayPopup();
                });
            });
        });

        function changeQuantity(delta) {
            currentQuantity = Math.max(1, Math.min(10, currentQuantity + delta));
            document.getElementById('diceQuantityPopup').textContent = currentQuantity;
            updateDiceDisplayPopup();
        }

        function changeModifier(delta) {
            currentModifier = Math.max(-10, Math.min(10, currentModifier + delta));
            document.getElementById('diceModifierPopup').textContent = currentModifier;
        }



        // Keyboard shortcuts for popup version
        document.addEventListener('keydown', function(event) {
            const popup = document.getElementById('diceRollerPopup');
            
            if (popup.style.display === 'block') {
                if (event.key === 'Escape') {
                    toggleDiceRoller();
                } else if (event.key === 'Enter') {
                    const rollBtn = document.getElementById('rollDiceBtnPopup');
                    if (!rollBtn.disabled) {
                        rollDicePopup();
                    }
                }
            }
        });

        // Message Board Functions
        let messages = [];
        let currentMessageTab = 'all';

        function toggleMessageBoard() {
            const popup = document.getElementById('messageBoardPopup');
            if (popup.style.display === 'block') {
                popup.style.display = 'none';
            } else {
                popup.style.display = 'block';
                updateCharacterDropdown();
                loadMessages();
            }
        }

        function updateCharacterDropdown() {
            const select = document.getElementById('messageCharacterSelect');
            select.innerHTML = '<option value="">Select Character...</option>';
            
            characters.forEach(character => {
                const option = document.createElement('option');
                option.value = character.name;
                option.textContent = character.name;
                select.appendChild(option);
            });
        }

        function sendMessage() {
            const characterSelect = document.getElementById('messageCharacterSelect');
            const messageInput = document.getElementById('messageInput');
            const character = characterSelect.value;
            const content = messageInput.value.trim();
            
            if (!character) {
                alert('Please select a character first!');
                return;
            }
            
            if (!content) {
                alert('Please enter a message!');
                return;
            }
            
            const message = {
                id: Date.now(),
                character: character,
                content: content,
                timestamp: new Date().toLocaleTimeString(),
                type: 'ic' // Default to in-character
            };
            
            messages.push(message);
            saveMessages();
            displayMessages();
            messageInput.value = '';
            
            // Auto-scroll to bottom
            const messageList = document.getElementById('messageList');
            messageList.scrollTop = messageList.scrollHeight;
        }

        function loadMessages() {
            const campaignPath = getCampaignPath();
            database.ref(`${campaignPath}/messages`).once('value')
                .then((snapshot) => {
                    messages = snapshot.val() || [];
                    displayMessages();
                })
                .catch((error) => {
                    console.error('Error loading messages:', error);
                    messages = [];
                    displayMessages();
                });
        }

        function saveMessages() {
            const campaignPath = getCampaignPath();
            database.ref(`${campaignPath}/messages`).set(messages)
                .catch((error) => {
                    console.error('Error saving messages:', error);
                });
        }

        function displayMessages() {
            const messageList = document.getElementById('messageList');
            messageList.innerHTML = '';
            
            const filteredMessages = currentMessageTab === 'all' 
                ? messages 
                : messages.filter(msg => msg.type === currentMessageTab);
            
            filteredMessages.forEach(message => {
                const messageItem = document.createElement('div');
                messageItem.className = 'message-item';
                
                messageItem.innerHTML = `
                    <div class="message-header">
                        <span class="message-character">${message.character}</span>
                        <span class="message-time">${message.timestamp}</span>
                    </div>
                    <div class="message-content">${message.content}</div>
                `;
                
                messageList.appendChild(messageItem);
            });
            
            // Auto-scroll to bottom
            messageList.scrollTop = messageList.scrollHeight;
        }

        function switchMessageTab(tab) {
            currentMessageTab = tab;
            
            // Update active tab
            document.querySelectorAll('.message-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
            
            displayMessages();
        }

        // Keyboard shortcuts for message board
        document.addEventListener('keydown', function(event) {
            const messageBoard = document.getElementById('messageBoardPopup');
            
            if (messageBoard.style.display === 'block') {
                if (event.key === 'Escape') {
                    toggleMessageBoard();
                } else if (event.key === 'Enter' && document.activeElement.id === 'messageInput') {
                    sendMessage();
                }
            }
        });

        // Setup real-time message listener
        function setupMessageListener() {
            const campaignPath = getCampaignPath();
            database.ref(`${campaignPath}/messages`).on('value', (snapshot) => {
                messages = snapshot.val() || [];
                if (document.getElementById('messageBoardPopup').style.display === 'block') {
                    displayMessages();
                }
            });
        }

        // Setup real-time listener
        function setupRealtimeListener() {
            const campaignPath = getCampaignPath();
            const charactersRef = database.ref(`${campaignPath}/characters`);
            
            console.log(`Setting up listener for guild: ${getGuildId()}, campaign: ${currentCampaignId} at path: ${campaignPath}/characters`);
            
            charactersRef.on('value', (snapshot) => {
                const data = snapshot.val();
                console.log(`Data received for guild ${getGuildId()}, campaign ${currentCampaignId}:`, data);
                
                if (data) {
                    characters = Object.keys(data).map(key => ({
                        id: key,
                        ...data[key]
                    }));
                    
                    // Load items and spells for each character
                    characters.forEach(character => {
                        // Load items
                        if (character.items) {
                            characterItems[character.id] = Object.keys(character.items).map(itemKey => ({
                                id: itemKey,
                                ...character.items[itemKey]
                            }));
                        } else {
                            characterItems[character.id] = [];
                        }
                        
                        // Load spells
                        if (character.spells) {
                            if (!characterSpells[character.id]) {
                                characterSpells[character.id] = {};
                            }
                            characterSpells[character.id] = character.spells;
                        } else {
                            if (!characterSpells[character.id]) {
                                characterSpells[character.id] = {};
                            }
                        }
                    });
                } else {
                    characters = [];
                    characterItems = {};
                    characterSpells = {};
                }
                
                renderCharacters();
                renderEnemies();
                updateConnectionStatus();
            }, (error) => {
                console.error('Firebase data error:', error);
                updateConnectionStatus();
            });

            // Setup enemy listener (copied from character listener)
            const enemiesRef = database.ref(`${campaignPath}/enemies`);
            
            enemiesRef.on('value', (snapshot) => {
                const data = snapshot.val();
                console.log(`Enemy data received for guild ${getGuildId()}, campaign ${currentCampaignId}:`, data);
                
                if (data) {
                    enemies = Object.keys(data).map(key => ({
                        id: key,
                        ...data[key]
                    }));
                } else {
                    enemies = [];
                }
                
                renderEnemies();
            }, (error) => {
                console.error('Firebase enemy data error:', error);
            });

            // Connection status
            const connectedRef = database.ref('.info/connected');
            connectedRef.on('value', (snap) => {
                isConnected = snap.val();
                console.log('Firebase connection status:', isConnected);
                updateConnectionStatus();
            }, (error) => {
                console.error('Firebase connection error:', error);
                isConnected = false;
                updateConnectionStatus();
            });
        }

        // Update connection status
        function updateConnectionStatus() {
            const statusElement = document.getElementById('connectionStatus');
            if (isConnected) {
                statusElement.textContent = '🟢 Connected';
                statusElement.className = 'connection-status';
            } else {
                statusElement.textContent = '🔴 Disconnected';
                statusElement.className = 'connection-status disconnected';
            }
        }

        // Track newly added characters for animation
        let newCharacterTimestamp = null;
        let newEnemyTimestamp = null;

        // Add a new character
        function addCharacter() {
            const campaignPath = getCampaignPath();
            const timestamp = Date.now();
            newCharacterTimestamp = timestamp;
            
            const newCharacter = {
                name: "New Character",
                class: "Fighter",
                level: 1,
                race: "Human",
                hp: 10,
                ac: 10,
                strength: 10,
                dexterity: 10,
                constitution: 10,
                intelligence: 10,
                wisdom: 10,
                charisma: 10,
                isDead: false,
                lastUpdated: timestamp
            };
            
            console.log(`Adding character to guild: ${getGuildId()}, campaign: ${currentCampaignId} at path: ${campaignPath}/characters`);
            
            // Add the character to Firebase
            database.ref(`${campaignPath}/characters`).push(newCharacter);
        }

        // Enemy functions (copied from character functions)

        // Add a new enemy
        function addEnemy() {
            const campaignPath = getCampaignPath();
            const timestamp = Date.now();
            
            // Store timestamp for animation (same as character system)
            newEnemyTimestamp = timestamp;
            
            const newEnemy = {
                name: "New Enemy",
                hp: 10,
                maxHp: 10,
                ac: 10,
                description: "",
                isDead: false,
                lastUpdated: timestamp
            };
            
            console.log(`Adding enemy to guild: ${getGuildId()}, campaign: ${currentCampaignId} at path: ${campaignPath}/enemies`);
            
            // Add the enemy to Firebase
            database.ref(`${campaignPath}/enemies`).push(newEnemy);
        }

        // Toggle enemy death status (copied from character toggleDeath)
        function toggleEnemyDeath(id) {
            const enemy = enemies.find(e => e.id === id);
            if (!enemy) return;
            
            const newDeathStatus = !enemy.isDead;
            updateEnemy(id, 'isDead', newDeathStatus);
        }

        // Update enemy field (copied from updateCharacter)
        function updateEnemy(id, field, value) {
            const campaignPath = getCampaignPath();
            const updates = {};
            updates[`${campaignPath}/enemies/${id}/${field}`] = value;
            updates[`${campaignPath}/enemies/${id}/lastUpdated`] = Date.now();
            database.ref().update(updates);
        }

        // Remove enemy with confirmation (copied from removeCharacter)
        function removeEnemy(id) {
            const enemy = enemies.find(e => e.id === id);
            const enemyName = enemy ? enemy.name || 'Unnamed Enemy' : 'this enemy';
            
            showDeleteConfirmation(enemyName, id, 'enemy');
        }

        // Actually delete the enemy after confirmation (copied from confirmDeleteCharacter)
        function confirmDeleteEnemy(id) {
            const campaignPath = getCampaignPath();
            console.log(`Removing enemy ${id} from guild: ${getGuildId()}, campaign: ${currentCampaignId}`);
            database.ref(`${campaignPath}/enemies/${id}`).remove();
        }

        // Create enemy card (reuses character card structure)
        function createEnemyCard(enemy, index) {
            // Convert enemy to character-like structure for reuse
            const enemyAsCharacter = {
                id: enemy.id,
                name: enemy.name || 'Unnamed Enemy',
                hp: enemy.hp || 10,        // Current HP for the HP field
                ac: enemy.ac || 10,        // AC for the AC field  
                acMax: enemy.maxHp || enemy.hp || 10, // Max HP for the HP field
                isDead: enemy.isDead || false,
                isHidden: enemy.isHidden || false,  // Include hidden state
                // Use monster data for class, race, and ability scores
                class: enemy.class || '',
                level: 1,
                race: enemy.race || '',
                strength: enemy.strength || 10,
                dexterity: enemy.dexterity || 10,
                constitution: enemy.constitution || 10,
                intelligence: enemy.intelligence || 10,
                wisdom: enemy.wisdom || 10,
                charisma: enemy.charisma || 10,
                bio: enemy.description || '',
                // Use monster image if available
                photo: enemy.imageUrl || '',
                // Mark as enemy for conditional display
                isEnemy: true,
                // Add lastUpdated for animation (same as character system)
                lastUpdated: enemy.lastUpdated,
                // Other fields enemies don't need
                activeEffects: '',
                ability1: '',
                ability2: '',
                ability3: '',
                ultimate: '',
                weapon: '',
                armor: '',
                shield: '',
                items: '',
                background: '',
                personality: '',
                goals: '',
                deathSaves: 0
            };

            // Create the card using the character function
            const card = createCharacterCard(enemyAsCharacter, index);
            
            // Add enemy class and modify for enemy styling
            card.classList.add('enemy');
            
            // Remove race classes that cause gold styling
            card.classList.forEach(className => {
                if (className.startsWith('race-')) {
                    card.classList.remove(className);
                }
            });
            
            // Update the delete button to use enemy functions
            const deleteBtn = card.querySelector('.remove-card-btn');
            if (deleteBtn) {
                deleteBtn.onclick = () => removeEnemy(enemy.id);
            }
            
            // Update the death toggle button to use enemy functions
            const deathBtn = card.querySelector('.death-toggle-btn');
            if (deathBtn) {
                deathBtn.onclick = () => toggleEnemyDeath(enemy.id);
                deathBtn.textContent = enemy.isDead ? '💀 Dead' : '⚔️ Alive';
            }
            
            // Update all input onchange handlers to use enemy functions
            const inputs = card.querySelectorAll('input, textarea, select');
            inputs.forEach(input => {
                const onchange = input.getAttribute('onchange');
                if (onchange && onchange.includes('updateCharacter')) {
                    const newOnchange = onchange.replace('updateCharacter', 'updateEnemy').replace(enemyAsCharacter.id, enemy.id);
                    input.setAttribute('onchange', newOnchange);
                }
            });
            
            // Apply hidden state if enemy is hidden
            if (enemy.isHidden) {
                card.classList.add('hidden-monster');
            }
            
            return card;
        }

        // Render all enemies (copied from renderCharacters pattern)
        function renderEnemies() {
            const enemyDeck = document.getElementById('enemyDeck');
            if (!enemyDeck) return;
            
            enemyDeck.innerHTML = '';
            
            enemies.forEach((enemy, index) => {
                const card = createEnemyCard(enemy, index);
                enemyDeck.appendChild(card);
            });
        }





        // Handle monster image loading errors by falling back to placeholder
        function handleImageError(img) {
            if (img.src && !img.src.includes('placeholder.png')) {
                console.log(`Monster image failed to load: ${img.src}, using placeholder`);
                img.src = 'monster-images/placeholder.png';
            }
        }



        // Show delete confirmation dialog
        function removeCharacter(id) {
            const character = characters.find(char => char.id === id);
            const characterName = character ? character.name || 'Unnamed Character' : 'this character';
            
            showDeleteConfirmation(characterName, id, 'character');
        }

        // Show delete confirmation overlay on specific card
        function showDeleteConfirmation(itemName, itemId, itemType = 'character') {
            // Find the card element
            const card = document.querySelector(`[data-character-id="${itemId}"]`);
            if (!card) {
                console.error('Card not found for deletion confirmation');
                return;
            }

            // Remove any existing delete overlay
            const existingOverlay = card.querySelector('.delete-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }

            // Clone the delete overlay template
            const template = document.getElementById('deleteOverlayTemplate');
            const overlay = template.cloneNode(true);
            overlay.id = ''; // Remove template ID
            overlay.style.display = 'block';
            
            // Update the message
            const message = overlay.querySelector('.delete-message');
            message.textContent = `Are you sure you want to delete ${itemName}?`;
            
            // Store the item info for the confirm function
            overlay.dataset.itemId = itemId;
            overlay.dataset.itemType = itemType;
            overlay.dataset.itemName = itemName;
            
            // Add overlay to card
            card.style.position = 'relative';
            card.appendChild(overlay);
            
            // Add keyboard support
            const handleKeyPress = (e) => {
                if (e.key === 'Escape') {
                    closeDeleteOverlay();
                    document.removeEventListener('keydown', handleKeyPress);
                }
            };
            document.addEventListener('keydown', handleKeyPress);
            
            // Focus on overlay for keyboard navigation
            overlay.focus();
        }

        // Hide delete confirmation overlay
        function closeDeleteOverlay() {
            // Find and remove any delete overlays
            const overlays = document.querySelectorAll('.delete-overlay:not(#deleteOverlayTemplate)');
            overlays.forEach(overlay => overlay.remove());
        }

        // Global function for confirm delete button
        function confirmDelete() {
            // Find the active overlay
            const overlay = document.querySelector('.delete-overlay:not(#deleteOverlayTemplate)');
            if (!overlay) return;
            
            const itemId = overlay.dataset.itemId;
            const itemType = overlay.dataset.itemType;
            
            // Call appropriate delete function
            if (itemType === 'enemy') {
                confirmDeleteEnemy(itemId);
            } else {
                confirmDeleteCharacter(itemId);
            }
            
            // Close overlay
            closeDeleteOverlay();
        }

        // Actually delete the character after confirmation
        function confirmDeleteCharacter(id) {
            const campaignPath = getCampaignPath();
            console.log(`Removing character ${id} from guild: ${getGuildId()}, campaign: ${currentCampaignId}`);
            database.ref(`${campaignPath}/characters/${id}`).remove();
        }

        // Show item delete confirmation overlay
        function showItemDeleteConfirmation(itemName, itemId, characterId, itemCard) {
            // Remove any existing delete overlay on this card
            const existingOverlay = itemCard.querySelector('.item-delete-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }

            // Create the overlay
            const overlay = document.createElement('div');
            overlay.className = 'item-delete-overlay';
            overlay.innerHTML = `
                <h3>Delete Item</h3>
                <p>Are you sure you want to delete "${itemName}"?</p>
                <div class="delete-overlay-buttons">
                    <button class="delete-confirm-btn">Delete</button>
                    <button class="delete-cancel-btn">Cancel</button>
                </div>
            `;
            
            // Add event listeners with stopPropagation
            const confirmBtn = overlay.querySelector('.delete-confirm-btn');
            const cancelBtn = overlay.querySelector('.delete-cancel-btn');
            
            confirmBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                confirmItemDelete(itemId, characterId);
            });
            
            cancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeItemDeleteOverlay(itemId);
            });
            
            // Stop propagation on the overlay itself
            overlay.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            
            // Add overlay to card
            itemCard.style.position = 'relative';
            itemCard.appendChild(overlay);
            overlay.style.display = 'block';
            
            // Add keyboard support
            const handleKeyPress = (e) => {
                if (e.key === 'Escape') {
                    closeItemDeleteOverlay(itemId);
                    document.removeEventListener('keydown', handleKeyPress);
                }
            };
            document.addEventListener('keydown', handleKeyPress);
        }

        // Show spell delete confirmation overlay
        function showSpellDeleteConfirmation(spellName, characterId, spellId, spellCard) {
            // Remove any existing delete overlay on this card
            const existingOverlay = spellCard.querySelector('.spell-delete-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }

            // Create the overlay
            const overlay = document.createElement('div');
            overlay.className = 'spell-delete-overlay';
            overlay.innerHTML = `
                <h3>Delete Spell</h3>
                <p>Are you sure you want to delete "${spellName}"?</p>
                <div class="delete-overlay-buttons">
                    <button class="delete-confirm-btn">Delete</button>
                    <button class="delete-cancel-btn">Cancel</button>
                </div>
            `;
            
            // Add event listeners with stopPropagation
            const confirmBtn = overlay.querySelector('.delete-confirm-btn');
            const cancelBtn = overlay.querySelector('.delete-cancel-btn');
            
            confirmBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                confirmSpellDelete(characterId, spellId);
            });
            
            cancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                closeSpellDeleteOverlay(spellId);
            });
            
            // Stop propagation on the overlay itself
            overlay.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            
            // Add overlay to card
            spellCard.style.position = 'relative';
            spellCard.appendChild(overlay);
            overlay.style.display = 'block';
            
            // Add keyboard support
            const handleKeyPress = (e) => {
                if (e.key === 'Escape') {
                    closeSpellDeleteOverlay(spellId);
                    document.removeEventListener('keydown', handleKeyPress);
                }
            };
            document.addEventListener('keydown', handleKeyPress);
        }

        // Close item delete overlay
        function closeItemDeleteOverlay(itemId) {
            const itemCard = document.querySelector(`[data-item-id="${itemId}"]`);
            if (itemCard) {
                const overlay = itemCard.querySelector('.item-delete-overlay');
                if (overlay) {
                    overlay.remove();
                }
            }
        }

        // Close spell delete overlay
        function closeSpellDeleteOverlay(spellId) {
            const spellCard = document.querySelector(`[data-spell-id="${spellId}"]`);
            if (spellCard) {
                const overlay = spellCard.querySelector('.spell-delete-overlay');
                if (overlay) {
                    overlay.remove();
                }
            }
        }

        // Confirm item deletion
        function confirmItemDelete(itemId, characterId) {
            closeItemDeleteOverlay(itemId);
            confirmDeleteItem(itemId, characterId);
        }

        // Confirm spell deletion
        function confirmSpellDelete(characterId, spellId) {
            closeSpellDeleteOverlay(spellId);
            confirmDeleteSpell(characterId, spellId);
        }

        // Update a character field
        function updateCharacter(id, field, value) {
            const campaignPath = getCampaignPath();
            const updates = {};
            updates[`${campaignPath}/characters/${id}/${field}`] = value;
            updates[`${campaignPath}/characters/${id}/lastUpdated`] = Date.now();
            database.ref().update(updates);
            
            // Highlight stats if this was a stat update
            if (['strength', 'dexterity', 'constitution', 'intelligence', 'wisdom', 'charisma'].includes(field)) {
                setTimeout(() => highlightStats(id), 100);
            }
            
            // Update card texture if race was changed
            if (field === 'race') {
                setTimeout(() => updateCardTexture(id, value), 100);
            }
        }

        // Highlight highest and lowest stats
        function highlightStats(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            const card = document.querySelector(`[data-character-id="${characterId}"]`);
            if (!card) return;

            // Get all shield wrappers for this specific card
            const shieldWrappers = card.querySelectorAll('.stat-shield-wrapper');
            
            // Remove existing highlighting from shield wrappers
            shieldWrappers.forEach(wrapper => {
                wrapper.classList.remove('highest-stat', 'lowest-stat');
            });

            // Get stat values for this specific character only
            const stats = [
                { field: 'strength', value: character.strength || 0 },
                { field: 'dexterity', value: character.dexterity || 0 },
                { field: 'constitution', value: character.constitution || 0 },
                { field: 'intelligence', value: character.intelligence || 0 },
                { field: 'wisdom', value: character.wisdom || 0 },
                { field: 'charisma', value: character.charisma || 0 }
            ];

            // Find highest and lowest stats for this character only
            const maxStat = Math.max(...stats.map(s => s.value));
            const minStat = Math.min(...stats.map(s => s.value));

            // Apply highlighting only to this character's stats
            // Only highlight if there's actually a difference between stats
            if (maxStat !== minStat && maxStat > 0) {
                // Find and highlight the highest stat (only the first one if there are ties)
                const maxStats = stats.filter(stat => stat.value === maxStat);
                if (maxStats.length > 0) {
                    const inputs = card.querySelectorAll('.ability-input');
                    const input = Array.from(inputs).find(input => 
                        input.getAttribute('onchange') && 
                        input.getAttribute('onchange').includes(`'${maxStats[0].field}'`)
                    );
                    if (input) {
                        const wrapper = input.closest('.stat-shield-wrapper');
                        if (wrapper) wrapper.classList.add('highest-stat');
                    }
                }

                // Find and highlight the lowest stat (only the first one if there are ties)
                const minStats = stats.filter(stat => stat.value === minStat);
                if (minStats.length > 0) {
                    const inputs = card.querySelectorAll('.ability-input');
                    const input = Array.from(inputs).find(input => 
                        input.getAttribute('onchange') && 
                        input.getAttribute('onchange').includes(`'${minStats[0].field}'`)
                    );
                    if (input) {
                        const wrapper = input.closest('.stat-shield-wrapper');
                        if (wrapper) wrapper.classList.add('lowest-stat');
                    }
                }
            }
        }

        // Toggle death status
        function toggleDeath(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            const newDeathStatus = !character.isDead;
            updateCharacter(characterId, 'isDead', newDeathStatus);
        }

        // Toggle death save bubbles
        function toggleDeathSave(characterId, bubbleNumber) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;
            
            const currentSaves = character.deathSaves || 0;
            let newSaves;
            
            if (currentSaves >= bubbleNumber) {
                // If clicking on a filled bubble or higher, reduce to one less
                newSaves = bubbleNumber - 1;
            } else {
                // If clicking on an empty bubble, fill up to that bubble
                newSaves = bubbleNumber;
            }
            
            updateCharacter(characterId, 'deathSaves', newSaves);
        }

        // Deck Popup Functions
        let characterItems = {}; // Store items for each character: { characterId: [items] }
        let characterSpells = {}; // Store spells for each character: { characterId: {spellId: spell} }
        let currentDeckPopup = null;

        function toggleDeck(characterId) {
            const button = document.getElementById(`deck-btn-${characterId}`);
            
            if (!button) return;
            
            if (currentDeckPopup) {
                // Close existing popup
                closeDeckPopup();
            } else {
                // Open deck popup
                openDeckPopup(characterId);
            }
        }

        function openDeckPopup(characterId) {
            const character = characters.find(c => c.id === characterId);
            if (!character) return;

            // Create popup
            const popup = document.createElement('div');
            popup.className = 'deck-popup';
            popup.id = 'deck-popup';
            
            popup.innerHTML = `
                <button class="deck-popup-close" onclick="closeDeckPopup(event)">✕</button>
                <div class="deck-main-container">
                    <div class="deck-title" id="deck-title">Character's Deck</div>
                    <div class="deck-character-display" id="deck-character-display">
                        <!-- Character card will be populated here -->
                    </div>
                    <div class="deck-content-rows">
                        <div class="deck-rows-container">
                            <div class="deck-row deck-row-items">
                                <div class="deck-row-header">Items</div>
                                <div class="deck-row-content">
                                    <div class="deck-row-scroll" id="deck-items-scroll">
                                        <!-- Items will be populated here -->
                                    </div>
                                </div>
                            </div>
                            <div class="deck-row deck-row-spells">
                                <div class="deck-row-header">Spells</div>
                                <div class="deck-row-content">
                                    <div class="deck-row-scroll" id="deck-spells-scroll">
                                        <!-- Spells will be populated here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Spell Library Section -->
                        <div class="spell-browser-section">
                            <div class="spell-browser-header">
                                <h3>Spell Library</h3>
                                <div class="spell-browser-controls">
                                    <input type="text" id="spellSearchInput" class="spell-search-input" placeholder="Search spells..." onkeyup="filterSpells(this.value)">
                                    <select id="spellLevelFilter" class="spell-level-filter" onchange="filterSpellsByLevel(this.value)">
                                        <option value="">All Levels</option>
                                        <option value="0">Cantrip</option>
                                        <option value="1">1st Level</option>
                                        <option value="2">2nd Level</option>
                                        <option value="3">3rd Level</option>
                                        <option value="4">4th Level</option>
                                        <option value="5">5th Level</option>
                                        <option value="6">6th Level</option>
                                        <option value="7">7th Level</option>
                                        <option value="8">8th Level</option>
                                        <option value="9">9th Level</option>
                                    </select>
                                    <select id="spellSchoolFilter" class="spell-school-filter" onchange="filterSpellsBySchool(this.value)">
                                        <option value="">All Schools</option>
                                        <option value="abjuration">Abjuration</option>
                                        <option value="conjuration">Conjuration</option>
                                        <option value="divination">Divination</option>
                                        <option value="enchantment">Enchantment</option>
                                        <option value="evocation">Evocation</option>
                                        <option value="illusion">Illusion</option>
                                        <option value="necromancy">Necromancy</option>
                                        <option value="transmutation">Transmutation</option>
                                    </select>

                                </div>
                            </div>
                            <div class="spell-browser-container">
                                <div class="spell-browser-scroll" id="spellBrowserScroll">
                                    <div class="spell-browser-content" id="spellBrowserContent">
                                        <!-- Spell library cards will be dynamically loaded here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Append to main content area so it scrolls with the page
            const mainContent = document.querySelector('#main-content') || document.body;
            mainContent.appendChild(popup);
            currentDeckPopup = popup;
            
            // Show popup
            setTimeout(() => {
                popup.classList.add('open');
                populateDeckContent(characterId);
            }, 10);
            
            // Don't change button state since deck window covers main page
        }

        function closeDeckPopup(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
            }
            if (!currentDeckPopup) return;
            
            // Since we're using a copy, we just need to clean up the copy
            // The original character card stays in place and doesn't need to be moved back
            console.log('DEBUG: Closing deck popup - no character card movement needed (using copy approach)');
            
            // Start the 1-second fade-out animation
            currentDeckPopup.classList.remove('open');
            currentDeckPopup.classList.add('closing');
            
            // Clean up after fade completes
            setTimeout(() => {
                if (currentDeckPopup) {
                    currentDeckPopup.remove();
                    currentDeckPopup = null;
                }
            }, 1000);
        }

        function populateDeckContent(characterId) {
            // Update title with character name
            const titleElement = document.getElementById('deck-title');
            const characterDisplayElement = document.getElementById('deck-character-display');
            const itemsScrollElement = document.getElementById('deck-items-scroll');
            const spellsScrollElement = document.getElementById('deck-spells-scroll');
            
            if (!titleElement || !characterDisplayElement || !itemsScrollElement || !spellsScrollElement) return;
            
            // Find the actual character card
            const originalCard = document.querySelector(`[data-character-id="${characterId}"]`);
            if (!originalCard) return;
            
            // Check if there are multiple cards with the same ID (this would be a problem)
            const allCardsWithSameId = document.querySelectorAll(`[data-character-id="${characterId}"]`);
            console.log('DEBUG: Cards found with same ID:', allCardsWithSameId.length);
            if (allCardsWithSameId.length > 1) {
                console.warn('WARNING: Multiple character cards found with same ID!', allCardsWithSameId);
            }
            
            // Get character name for title
            const characterNameInput = originalCard.querySelector('.card-name');
            const characterName = characterNameInput ? characterNameInput.value || 'Character' : 'Character';
            titleElement.textContent = `${characterName}'s Deck`;
            
            // Create a copy of the character card for the deck display instead of moving the original
            const deckCardCopy = originalCard.cloneNode(true);
            deckCardCopy.classList.add('deck-character-card');
            
            // Store reference to original card so we can sync changes
            deckCardCopy.originalCard = originalCard;
            
            // Initialize full functionality for the cloned card
            initializeDeckCardFunctionality(deckCardCopy, characterId);
            
            // Toggle the deck button to "Close Deck" state on the copy
            const deckButton = deckCardCopy.querySelector('.open-deck-btn');
            if (deckButton) {
                deckButton.textContent = '✕ Close Deck';
                deckButton.style.background = '#dc2626';
                deckButton.onclick = () => closeDeckPopup();
            }
            
            // Hide the delete button for safety while viewing deck
            const deleteButton = deckCardCopy.querySelector('.remove-card-btn');
            if (deleteButton) {
                deleteButton.style.display = 'none';
            }
            
            characterDisplayElement.appendChild(deckCardCopy);
            
            // Add deck positioning with a slight delay for smooth transition
            setTimeout(() => {
                deckCardCopy.classList.add('deck-positioned');
            }, 100);
            
            // Populate items row
            populateItemsRow(characterId, itemsScrollElement);
            
            // Populate spells row
            populateSpellsRow(characterId, spellsScrollElement);
            
            // Initialize spell library
            initializeSpellLibrary(characterId);
        }

        // No longer needed - we're using the actual card with all its original functionality

        function populateItemsRow(characterId, itemsScrollElement) {
            // Add existing item cards first
            loadCharacterItemsToRow(characterId, itemsScrollElement);
            
            // Add "Add Item" button after existing cards
            const addItemButton = document.createElement('div');
            addItemButton.className = 'deck-add-item';
            addItemButton.onclick = () => addNewItemToDeck(characterId);
            addItemButton.innerHTML = `
                <div class="deck-add-item-icon">➕</div>
                <div class="deck-add-item-text">Add Item</div>
                <div class="deck-add-item-subtext">Create a new item card</div>
            `;
            itemsScrollElement.appendChild(addItemButton);
        }

        function populateSpellsRow(characterId, spellsScrollElement) {
            // Add existing spell cards first
            loadCharacterSpellsToRow(characterId, spellsScrollElement);
            
            // Add "Add Spell" button after existing cards
            const addSpellButton = document.createElement('div');
            addSpellButton.className = 'deck-add-spell';
            addSpellButton.onclick = () => addNewSpellToDeck(characterId);
            addSpellButton.innerHTML = `
                <div class="deck-add-spell-icon">✨</div>
                <div class="deck-add-spell-text">Add Spell</div>
                <div class="deck-add-spell-subtext">Create a new spell card</div>
            `;
            spellsScrollElement.appendChild(addSpellButton);
        }

        function loadCharacterItemsToRow(characterId, itemsScrollElement) {
            // Initialize items array if it doesn't exist
            if (!characterItems[characterId]) {
                characterItems[characterId] = [];
            }
            
            const items = characterItems[characterId];
            items.forEach((item, index) => {
                const itemCard = createItemCard(item, characterId);
                itemCard.classList.add('deck-item-card');
                
                // Add pre-deal state for animation
                itemCard.classList.add('pre-deal');
                itemsScrollElement.appendChild(itemCard);
                
                // Trigger dealing animation with staggered timing
                setTimeout(() => {
                    itemCard.classList.remove('pre-deal');
                    itemCard.classList.add('dealing');
                    
                    // Clean up animation class after animation completes
                    setTimeout(() => {
                        itemCard.classList.remove('dealing');
                    }, 600);
                }, 200 + (index * 100)); // Stagger by 100ms per card
            });
        }

        function loadCharacterSpellsToRow(characterId, spellsScrollElement) {
            // Initialize spells object if it doesn't exist
            if (!characterSpells) {
                characterSpells = {};
            }
            if (!characterSpells[characterId]) {
                characterSpells[characterId] = {};
            }
            
            // Convert object to array for iteration
            const spells = Object.values(characterSpells[characterId]);
            const itemCount = characterItems[characterId] ? characterItems[characterId].length : 0;
            
            spells.forEach((spell, index) => {
                const spellCard = createSpellCard(spell, characterId);
                
                // Add pre-deal state for animation
                spellCard.classList.add('pre-deal');
                spellsScrollElement.appendChild(spellCard);
                
                // Trigger dealing animation with staggered timing (after items)
                setTimeout(() => {
                    spellCard.classList.remove('pre-deal');
                    spellCard.classList.add('dealing');
                    
                    // Clean up animation class after animation completes
                    setTimeout(() => {
                        spellCard.classList.remove('dealing');
                    }, 600);
                }, 300 + (itemCount * 100) + (index * 100)); // Start after items, stagger by 100ms per card
            });
        }

        function loadCharacterItemsToDeck(characterId) {
            const scrollContent = document.getElementById('deck-scroll-content');
            if (!scrollContent) return;
            
            // Initialize items array if it doesn't exist
            if (!characterItems[characterId]) {
                characterItems[characterId] = [];
            }
            
            const items = characterItems[characterId];
            items.forEach(item => {
                const itemCard = createItemCard(item, characterId);
                itemCard.classList.add('deck-item-card');
                scrollContent.appendChild(itemCard);
            });
        }

        function addNewItemToDeck(characterId) {
            const newItem = {
                id: Date.now().toString(),
                name: '',
                description: '',
                characterId: characterId,
                createdAt: Date.now()
            };
            
            // Initialize items array if it doesn't exist
            if (!characterItems[characterId]) {
                characterItems[characterId] = [];
            }
            
            characterItems[characterId].push(newItem);
            
            // Save to Firebase
            const campaignPath = getCampaignPath();
            database.ref(`${campaignPath}/characters/${characterId}/items/${newItem.id}`).set(newItem);
            
            // Add to the deck popup
            const itemsScrollElement = document.getElementById('deck-items-scroll');
            if (itemsScrollElement) {
                const itemCard = createItemCard(newItem, characterId);
                itemCard.classList.add('deck-item-card');
                
                // Insert before the "Add Item" button
                const addButton = itemsScrollElement.querySelector('.deck-add-item');
                if (addButton) {
                    itemsScrollElement.insertBefore(itemCard, addButton);
                } else {
                    itemsScrollElement.appendChild(itemCard);
                }
                
                // Focus on name field
                setTimeout(() => {
                    const nameField = itemCard.querySelector('.item-card-name');
                    if (nameField) {
                        nameField.focus();
                        nameField.select();
                    }
                }, 100);
            }
        }

        function addNewSpellToDeck(characterId) {
            const newSpell = {
                id: Date.now().toString(),
                name: '',
                level: 'Cantrip',
                school: 'Evocation',
                description: '',
                characterId: characterId,
                createdAt: Date.now()
            };
            
            // Initialize spells object if it doesn't exist (consistent with spell explorer)
            if (!characterSpells) {
                characterSpells = {};
            }
            if (!characterSpells[characterId]) {
                characterSpells[characterId] = {};
            }
            
            characterSpells[characterId][newSpell.id] = newSpell;
            
            // Save to Firebase
            const campaignPath = getCampaignPath();
            database.ref(`${campaignPath}/characters/${characterId}/spells/${newSpell.id}`).set(newSpell);
            
            // Add to the deck popup
            const spellsScrollElement = document.getElementById('deck-spells-scroll');
            if (spellsScrollElement) {
                const spellCard = createSpellCard(newSpell, characterId);
                
                // Insert before the "Add Spell" button
                const addButton = spellsScrollElement.querySelector('.deck-add-spell');
                if (addButton) {
                    spellsScrollElement.insertBefore(spellCard, addButton);
                } else {
                    spellsScrollElement.appendChild(spellCard);
                }
                
                // Focus on name field
                setTimeout(() => {
                    const nameField = spellCard.querySelector('.spell-card-name');
                    if (nameField) {
                        nameField.focus();
                        nameField.select();
                    }
                }, 100);
            }
        }

        function createSpellCard(spell, characterId) {
            const spellCard = document.createElement('div');
            spellCard.className = 'spell-card';
            spellCard.dataset.spellId = spell.id;
            
            // Generate potential image path based on spell name
            const spellImagePath = getSpellImagePath(spell.name);
            const imageSection = spellImagePath ? `
                <div class="spell-card-image-section">
                    <img src="${spellImagePath}" alt="${spell.name}" class="spell-card-image" 
                         onerror="this.parentElement.style.display='none'">
                </div>
            ` : '';
            
            spellCard.innerHTML = `
                <div class="card-texture"></div>
                ${imageSection}
                <div class="spell-card-header">
                    <input type="text" class="spell-card-name" value="${spell.name}" placeholder="Spell Name" 
                           onchange="updateSpell('${characterId}', '${spell.id}', 'name', this.value)">
                </div>
                <div class="spell-card-body">
                    <input type="text" class="spell-card-level" value="${spell.level}" placeholder="Spell Level"
                           onchange="updateSpell('${characterId}', '${spell.id}', 'level', this.value)">
                    <textarea class="spell-card-description" placeholder="Spell description, components, range, duration, etc..."
                              onchange="updateSpell('${characterId}', '${spell.id}', 'description', this.value)">${spell.description}</textarea>
                </div>
                <div class="spell-card-footer">
                    <div class="spell-card-school" onclick="cycleSpellSchool('${characterId}', '${spell.id}')">${spell.school}</div>
                    <button class="delete-item-btn" onclick="deleteSpell('${characterId}', '${spell.id}', event)">🗑️</button>
                </div>
            `;
            
            return spellCard;
        }

        // Helper function to get spell image path
        function getSpellImagePath(spellName) {
            // Convert spell name to the same format used by the API (lowercase, hyphens)
            const spellIndex = spellName.toLowerCase()
                .replace(/'/g, '')
                .replace(/\s+/g, '-')
                .replace(/[^a-z0-9\-]/g, '');
            
            // Return the image path - the onerror handler will hide it if it doesn't exist
            return `spell-images/${spellIndex}.png`;
        }

        function updateSpell(characterId, spellId, field, value) {
            if (!characterSpells[characterId]) return;
            
            const spell = characterSpells[characterId][spellId];
            if (spell) {
                spell[field] = value;
                spell.lastUpdated = Date.now();
                
                // Save to Firebase
                const campaignPath = getCampaignPath();
                const updates = {};
                updates[`${campaignPath}/characters/${characterId}/spells/${spellId}/${field}`] = value;
                updates[`${campaignPath}/characters/${characterId}/spells/${spellId}/lastUpdated`] = Date.now();
                database.ref().update(updates);
            }
        }

        function deleteSpell(characterId, spellId, event) {
            if (event) event.stopPropagation(); // Prevent event bubbling
            
            // Find the spell card
            const spellCard = document.querySelector(`[data-spell-id="${spellId}"]`);
            if (!spellCard) return;
            
            // Get spell name for the confirmation
            const spellNameInput = spellCard.querySelector('.spell-card-name');
            const spellName = spellNameInput ? spellNameInput.value || 'Spell' : 'Spell';
            
            // Show delete confirmation overlay
            showSpellDeleteConfirmation(spellName, characterId, spellId, spellCard);
        }

        function confirmDeleteSpell(characterId, spellId) {
            if (!characterSpells[characterId]) return;
            
            delete characterSpells[characterId][spellId];
            
            // Remove from deck popup if open
            const spellCard = document.querySelector(`[data-spell-id="${spellId}"]`);
            if (spellCard) {
                spellCard.remove();
            }
            
            // Delete from Firebase
            const campaignPath = getCampaignPath();
            database.ref(`${campaignPath}/characters/${characterId}/spells/${spellId}`).remove();
        }

        function cycleSpellSchool(characterId, spellId) {
            const schools = ['Abjuration', 'Conjuration', 'Divination', 'Enchantment', 'Evocation', 'Illusion', 'Necromancy', 'Transmutation'];
            
            if (!characterSpells[characterId]) return;
            
            const spell = characterSpells[characterId][spellId];
            if (spell) {
                const currentIndex = schools.indexOf(spell.school);
                const nextIndex = (currentIndex + 1) % schools.length;
                spell.school = schools[nextIndex];
                
                // Save to Firebase
                const campaignPath = getCampaignPath();
                const updates = {};
                updates[`${campaignPath}/characters/${characterId}/spells/${spellId}/school`] = spell.school;
                updates[`${campaignPath}/characters/${characterId}/spells/${spellId}/lastUpdated`] = Date.now();
                database.ref().update(updates);
                
                // Update the display
                const spellCard = document.querySelector(`[data-spell-id="${spellId}"]`);
                if (spellCard) {
                    const schoolElement = spellCard.querySelector('.spell-card-school');
                    if (schoolElement) {
                        schoolElement.textContent = spell.school;
                    }
                }
            }
        }

        function loadCharacterItems(characterId) {
            // Initialize items array if it doesn't exist
            if (!characterItems[characterId]) {
                characterItems[characterId] = [];
            }
            
            renderCharacterItems(characterId);
        }

        function renderCharacterItems(characterId) {
            const itemsContainer = document.getElementById(`deck-items-${characterId}`);
            if (!itemsContainer) return;
            
            itemsContainer.innerHTML = '';
            
            const items = characterItems[characterId] || [];
            items.forEach(item => {
                const itemCard = createItemCard(item, characterId);
                itemsContainer.appendChild(itemCard);
            });
            
            // Show message if no items
            if (items.length === 0) {
                itemsContainer.innerHTML = `
                    <div style="flex: 0 0 320px; display: flex; align-items: center; justify-content: center; text-align: center; color: #8b7355; font-style: italic; padding: 40px; min-height: 480px; background: rgba(139, 115, 85, 0.1); border: 2px dashed #8b7355; border-radius: 8px; font-size: 1.1rem;">
                        <div>
                            <div style="font-size: 3rem; margin-bottom: 15px;">📦</div>
                            <div>No items in this deck yet.</div>
                            <div style="margin-top: 10px; font-size: 0.9rem;">Click "Add New Item" to get started!</div>
                        </div>
                    </div>
                `;
            }
            
            // Update navigation buttons
            updateDeckNavigation(characterId);
            
            // Add scroll listener to update navigation buttons
            const container = document.getElementById(`deck-items-${characterId}`);
            if (container) {
                container.addEventListener('scroll', () => updateDeckNavigation(characterId));
            }
        }

        function scrollDeckItems(characterId, direction) {
            const container = document.getElementById(`deck-items-${characterId}`);
            if (!container) return;
            
            const scrollAmount = 340; // Card width + gap
            container.scrollBy({
                left: direction * scrollAmount,
                behavior: 'smooth'
            });
            
            // Update navigation buttons after scroll
            setTimeout(() => updateDeckNavigation(characterId), 300);
        }

        function updateDeckNavigation(characterId) {
            const container = document.getElementById(`deck-items-${characterId}`);
            const leftBtn = document.getElementById(`deck-nav-left-${characterId}`);
            const rightBtn = document.getElementById(`deck-nav-right-${characterId}`);
            
            if (!container || !leftBtn || !rightBtn) return;
            
            const isAtStart = container.scrollLeft <= 0;
            const isAtEnd = container.scrollLeft >= container.scrollWidth - container.clientWidth;
            
            leftBtn.disabled = isAtStart;
            rightBtn.disabled = isAtEnd;
        }

        function addNewItem(characterId) {
            const newItem = {
                id: Date.now().toString(),
                name: '',
                description: '',
                characterId: characterId,
                createdAt: Date.now()
            };
            
            // Initialize items array if it doesn't exist
            if (!characterItems[characterId]) {
                characterItems[characterId] = [];
            }
            
            characterItems[characterId].push(newItem);
            renderCharacterItems(characterId);
            
            // Focus on the name field of the new item
            setTimeout(() => {
                const newItemCard = document.querySelector(`[data-item-id="${newItem.id}"] .item-card-name`);
                if (newItemCard) {
                    newItemCard.focus();
                    newItemCard.select();
                }
            }, 100);
        }

        function updateItem(itemId, field, value) {
            // Find the item across all characters
            for (const characterId in characterItems) {
                const items = characterItems[characterId];
                const item = items.find(i => i.id === itemId);
                if (item) {
                    item[field] = value;
                    item.lastUpdated = Date.now();
                    
                    // Save to Firebase
                    const campaignPath = getCampaignPath();
                    const updates = {};
                    updates[`${campaignPath}/characters/${characterId}/items/${itemId}/${field}`] = value;
                    updates[`${campaignPath}/characters/${characterId}/items/${itemId}/lastUpdated`] = Date.now();
                    database.ref().update(updates);
                    break;
                }
            }
        }

        function deleteItem(itemId, characterId, event) {
            if (event) event.stopPropagation(); // Prevent event bubbling
            
            // Find the item card
            const itemCard = document.querySelector(`[data-item-id="${itemId}"]`);
            if (!itemCard) return;
            
            // Get item name for the confirmation
            const itemNameInput = itemCard.querySelector('.item-card-name');
            const itemName = itemNameInput ? itemNameInput.value || 'Item' : 'Item';
            
            // Show delete confirmation overlay
            showItemDeleteConfirmation(itemName, itemId, characterId, itemCard);
        }

        function confirmDeleteItem(itemId, characterId) {
            const items = characterItems[characterId] || [];
            const itemIndex = items.findIndex(i => i.id === itemId);
            if (itemIndex > -1) {
                items.splice(itemIndex, 1);
                
                // Remove from deck popup if open
                const itemCard = document.querySelector(`[data-item-id="${itemId}"]`);
                if (itemCard) {
                    itemCard.remove();
                }
                
                // Delete from Firebase
                const campaignPath = getCampaignPath();
                database.ref(`${campaignPath}/characters/${characterId}/items/${itemId}`).remove();
                
                // Also update any other views that might show items
                renderCharacterItems(characterId);
            }
        }

        // Close deck popup when clicking outside
        document.addEventListener('click', function(event) {
            // Check if there's an open popup and the click is outside it
            if (currentDeckPopup && 
                !event.target.closest('.deck-popup') && 
                !event.target.closest('.open-deck-btn')) {
                closeDeckPopup();
            }
        });

        // Enemy attack functions
        let currentAttackTarget = null;

        function showAttackModal(characterId) {
            currentAttackTarget = characterId;
            
            // Look for the target in both characters and enemies arrays
            let character = characters.find(c => c.id === characterId);
            if (!character) {
                character = enemies.find(e => e.id === characterId);
            }
            
            if (!character) {
                return;
            }
            
            // Find the character card
            const card = document.querySelector(`[data-character-id="${characterId}"]`);
            if (!card) {
                return;
            }
            
            // Remove any existing overlay
            const existingOverlay = card.querySelector('.attack-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            // Clone the overlay template
            const template = document.getElementById('attackOverlayTemplate');
            if (!template) {
                return;
            }
            
            const overlay = template.cloneNode(true);
            overlay.id = `attackOverlay-${characterId}`;
            overlay.style.display = 'block';
            
            // Add the overlay to the card
            card.appendChild(overlay);
            
            // Focus the damage input
            const damageInput = overlay.querySelector('.damage-input');
            damageInput.value = '';
            damageInput.focus();
            
            // Add keyboard event listener for this overlay
            document.addEventListener('keydown', handleAttackModalKeys);
        }

        function closeAttackOverlay() {
            if (currentAttackTarget) {
                const overlay = document.getElementById(`attackOverlay-${currentAttackTarget}`);
                if (overlay) {
                    overlay.remove();
                }
                currentAttackTarget = null;
            }
            
            // Remove keyboard event listener
            document.removeEventListener('keydown', handleAttackModalKeys);
        }


        
        // Keep the old function name for backward compatibility
        function closeAttackModal() {
            closeAttackOverlay();
        }

        function handleAttackModalKeys(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                confirmAttack();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                closeAttackOverlay();
            }
        }

        function confirmAttack() {
            console.log('confirmAttack called');
            if (!currentAttackTarget) {
                console.log('No current attack target');
                return;
            }
            
            const overlay = document.getElementById(`attackOverlay-${currentAttackTarget}`);
            if (!overlay) {
                console.log('No overlay found');
                return;
            }
            const damage = parseInt(overlay.querySelector('.damage-input').value) || 0;
            console.log('Damage amount:', damage);
            if (damage <= 0) {
                alert('Please enter a valid damage amount!');
                return;
            }
            
            // Look for the target in both characters and enemies arrays
            let character = characters.find(c => c.id === currentAttackTarget);
            let isEnemy = false;
            if (!character) {
                character = enemies.find(e => e.id === currentAttackTarget);
                isEnemy = true;
            }
            
            if (!character) return;
            
            // Subtract damage from current HP
            const newHp = Math.max(0, (character.hp || 0) - damage);
            

            
            // Use the appropriate update function based on whether it's an enemy or character
            if (isEnemy) {
                updateEnemy(currentAttackTarget, 'hp', newHp);
                // If HP reaches 0, mark as dead
                if (newHp === 0) {
                    updateEnemy(currentAttackTarget, 'isDead', true);
                }
            } else {
                updateCharacter(currentAttackTarget, 'hp', newHp);
                // If HP reaches 0, mark as dead
                if (newHp === 0) {
                    updateCharacter(currentAttackTarget, 'isDead', true);
                }
            }
            
            closeAttackOverlay();
        }



        function toggleMonsterVisibility(characterId) {
            // Look for the target in both characters and enemies arrays
            let character = characters.find(c => c.id === characterId);
            let isEnemy = false;
            if (!character) {
                character = enemies.find(e => e.id === characterId);
                isEnemy = true;
            }
            
            if (!character) return;
            
            const newHiddenStatus = !character.isHidden;
            const card = document.querySelector(`[data-character-id="${characterId}"]`);
            
            if (!card) return;
            
            // Prevent multiple flips if already flipping
            if (card.classList.contains('flipping')) return;
            
            // Clean up any previous states
            card.classList.remove('flip-content-ready');
            
            // Step 1: Start the flip animation and fade out content immediately
            card.classList.add('flipping');
            
            // Step 2: At the halfway point (400ms), when card is sideways, switch content
            setTimeout(() => {
                // Update visual state first
                if (newHiddenStatus) {
                    card.classList.add('hidden-monster');
                } else {
                    card.classList.remove('hidden-monster');
                }
                
                // Update data
                if (isEnemy) {
                    updateEnemy(characterId, 'isHidden', newHiddenStatus);
                } else {
                    updateCharacter(characterId, 'isHidden', newHiddenStatus);
                }
                
                // Signal that content is ready to fade back in
                card.classList.add('flip-content-ready');
                
            }, 400); // Halfway through 0.8s animation
            
            // Step 3: Complete the flip animation
            setTimeout(() => {
                card.classList.remove('flipping');
                // Keep flip-content-ready for a moment to ensure smooth fade-in
                setTimeout(() => {
                    card.classList.remove('flip-content-ready');
                }, 300); // Allow fade-in to complete
            }, 800); // Full 0.8s animation duration
        }

        // Helper function to get active tab class
        function getActiveTabClass(characterId, tabName) {
            const activeTab = activeTabs[characterId] || 'stats';
            return activeTab === tabName ? 'active' : '';
        }

        // Switch between tabs
        function switchTab(characterId, tabName) {
            // Store the active tab for this character
            activeTabs[characterId] = tabName;
            
            // Get the card element
            const card = document.querySelector(`[data-character-id="${characterId}"]`) || 
                        document.querySelector(`#stats-content-${characterId}`)?.closest('.character-card');
            
            if (!card) return;

            // Update tab buttons
            const tabButtons = card.querySelectorAll('.tab-btn');
            tabButtons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.getAttribute('data-tab') === tabName) {
                    btn.classList.add('active');
                }
            });

            // Update tab content
            const tabContents = card.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
                if (content.id === `${tabName}-content-${characterId}`) {
                    content.classList.add('active');
                }
            });
        }

        // Initialize full functionality for deck popup character card copy
        function initializeDeckCardFunctionality(deckCard, characterId) {
            // Create unique ID namespace for the cloned card
            const deckPrefix = 'deck-';
            const deckCharacterId = deckPrefix + characterId;
            
            // Update all IDs to avoid conflicts
            const allElementsWithIds = deckCard.querySelectorAll('[id]');
            allElementsWithIds.forEach(element => {
                element.id = deckPrefix + element.id;
            });
            
            // Update data-character-id to the new prefixed version
            deckCard.setAttribute('data-character-id', deckCharacterId);
            
            // Initialize tab functionality with proper scoping
            const tabButtons = deckCard.querySelectorAll('.tab-btn');
            tabButtons.forEach(btn => {
                btn.removeAttribute('onclick'); // Remove old onclick
                btn.addEventListener('click', function() {
                    const tabName = btn.getAttribute('data-tab');
                    
                    // Update tab buttons within this specific card
                    tabButtons.forEach(button => {
                        button.classList.remove('active');
                    });
                    btn.classList.add('active');
                    
                    // Update tab content within this specific card
                    const tabContents = deckCard.querySelectorAll('.tab-content');
                    tabContents.forEach(content => {
                        content.classList.remove('active');
                        if (content.id === `${deckPrefix}${tabName}-content-${characterId}`) {
                            content.classList.add('active');
                        }
                    });
                    
                    // Update global state for consistency
                    activeTabs[characterId] = tabName;
                });
            });
            
            // Initialize input field functionality
            const inputs = deckCard.querySelectorAll('input, textarea, select');
            console.log('DEBUG: Found', inputs.length, 'input elements in deck card');
            
            inputs.forEach(input => {
                // Log input properties for debugging
                console.log('DEBUG: Input - id:', input.id, 'class:', input.className, 'name:', input.name, 'placeholder:', input.placeholder);
                
                // Remove any existing event listeners by cloning the element
                const newInput = input.cloneNode(true);
                input.parentNode.replaceChild(newInput, input);
                
                // Add new event listeners that sync with the original card
                newInput.addEventListener('input', function() {
                    syncWithOriginalCard(newInput, characterId);
                });
                newInput.addEventListener('change', function() {
                    syncWithOriginalCard(newInput, characterId);
                    
                    // Handle race changes for card styling - check for race input field
                    if (newInput.classList.contains('race-input-inline') || 
                        newInput.classList.contains('card-race') || 
                        newInput.name === 'race' || 
                        newInput.id.includes('race') ||
                        newInput.placeholder && newInput.placeholder.toLowerCase().includes('race')) {
                        console.log('DEBUG: Race changed to:', newInput.value);
                        updateDeckCardTexture(deckCard, newInput.value);
                    }
                });
            });
        }
        
        // Sync changes from deck card back to original card
        function syncWithOriginalCard(deckInput, characterId) {
            const originalCard = document.querySelector(`[data-character-id="${characterId}"]:not([data-character-id*="deck"])`);
            if (!originalCard) return;
            
            // Find corresponding input in original card using safer method
            const inputId = deckInput.id.replace('deck-', '');
            if (!inputId) return; // Skip if no valid ID
            
            let originalInput;
            try {
                // Try using getElementById first (most reliable)
                originalInput = document.getElementById(inputId);
                // Make sure it's actually in the original card
                if (originalInput && !originalCard.contains(originalInput)) {
                    originalInput = null;
                }
            } catch (e) {
                console.warn('Error finding original input:', e);
                return;
            }
            
            if (originalInput) {
                originalInput.value = deckInput.value;
                // Trigger change event on original to maintain functionality
                originalInput.dispatchEvent(new Event('input', { bubbles: true }));
                originalInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
        }
        
        // Update deck card race styling using existing system
        function updateDeckCardTexture(deckCard, newRace) {
            console.log('DEBUG: updateDeckCardTexture called with race:', newRace);
            if (!newRace) return;
            
            const textureElement = deckCard.querySelector('.card-texture');
            console.log('DEBUG: Found texture element:', !!textureElement);
            if (!textureElement) return;
            
            // Remove all existing race classes from texture
            textureElement.className = 'card-texture';
            
            // Add new race class to texture using existing function
            textureElement.classList.add(getRaceTextureClass(newRace));
            
            // Remove all existing race classes from deck card
            deckCard.classList.forEach(className => {
                if (className.startsWith('race-')) {
                    deckCard.classList.remove(className);
                }
            });
            
            // Add new race class to deck card for header styling
            if (newRace) {
                const raceClass = 'race-' + getRaceTextureClass(newRace);
                deckCard.classList.add(raceClass);
            }
        }

        // Render all characters
        function renderCharacters() {
            const deck = document.getElementById('characterDeck');
            deck.innerHTML = '';
            
            characters.forEach((character, index) => {
                const card = createCharacterCard(character, index);
                deck.appendChild(card);
                
                // Highlight stats for this character
                setTimeout(() => highlightStats(character.id), 50);
            });
        }

        // Render all enemies
        function renderEnemies() {
            const enemyDeck = document.getElementById('enemyDeck');
            enemyDeck.innerHTML = '';
            
            enemies.forEach((enemy, index) => {
                const card = createEnemyCard(enemy, index);
                enemyDeck.appendChild(card);
                
                // Highlight stats for this enemy
                setTimeout(() => highlightStats(enemy.id), 50);
            });
        }

        // Get texture class based on character race
        function getRaceTextureClass(race) {
            if (!race) return 'default';
            
            // Convert race name to lowercase and replace spaces/hyphens with hyphens
            const normalizedRace = race.toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^a-z0-9-]/g, '');
            
            // Map of supported races to their texture classes
            const raceMap = {
                'human': 'human',
                'elf': 'elf', 
                'dwarf': 'dwarf',
                'halfling': 'halfling',
                'dragonborn': 'dragonborn',
                'tiefling': 'tiefling',
                'half-orc': 'half-orc',
                'gnome': 'gnome',
                'half-elf': 'half-elf',
                'aarakocra': 'aarakocra'
            };
            
            return raceMap[normalizedRace] || 'default';
        }

        // Update card texture based on race
        function updateCardTexture(characterId, race) {
            const card = document.querySelector(`[data-character-id="${characterId}"]`);
            if (!card) return;
            
            const textureElement = card.querySelector('.card-texture');
            if (!textureElement) return;
            
            // Remove all existing race classes from texture
            textureElement.className = 'card-texture';
            
            // Add new race class to texture
            textureElement.classList.add(getRaceTextureClass(race));
            
            // Remove all existing race classes from card
            card.classList.forEach(className => {
                if (className.startsWith('race-')) {
                    card.classList.remove(className);
                }
            });
            
            // Add new race class to card for header styling
            if (race) {
                const raceClass = 'race-' + getRaceTextureClass(race);
                card.classList.add(raceClass);
            }
        }

        // Create a character card element
        function createCharacterCard(character, index) {
            const card = document.createElement('div');
            card.className = 'character-card';
            if (character.isDead) {
                card.classList.add('dead');
            }
            
            // Add race class for styling
            if (character.race) {
                const raceClass = 'race-' + getRaceTextureClass(character.race);
                card.classList.add(raceClass);
            }
            
            // Add animation class for newly added characters or enemies
            // Check if this character was just added (within last 2 seconds)
            if (newCharacterTimestamp && character.lastUpdated === newCharacterTimestamp) {
                card.classList.add('new-card');
                console.log('Adding animation to new character:', character.name);
                // Clear the timestamp after applying animation
                setTimeout(() => {
                    newCharacterTimestamp = null;
                    card.classList.remove('new-card');
                }, 800); // Match animation duration
            }
            
            // Check if this is a newly added enemy
            if (newEnemyTimestamp && character.lastUpdated === newEnemyTimestamp) {
                card.classList.add('new-card');
                console.log('Adding animation to new enemy:', character.name);
                // Clear the timestamp after applying animation
                setTimeout(() => {
                    newEnemyTimestamp = null;
                    card.classList.remove('new-card');
                }, 800); // Match animation duration
            }
            
            card.setAttribute('data-character-id', character.id);
            
            card.innerHTML = `
                <div class="card-texture ${getRaceTextureClass(character.race)}"></div>
                <div class="card-header">
                    <!-- Top Section: Name + HP/AC -->
                    <div class="header-top-section">
                        <input
                            type="text"
                            value="${character.name}"
                            onchange="updateCharacter('${character.id}', 'name', this.value)"
                            class="editable-field card-name"
                        >
                        <div class="header-stats">
                            <div class="header-stat">
                                <div class="hex-wrapper">
                                    <span class="shield-icon">🛡️</span>
                                    <input
                                        type="number"
                                        value="${character.ac || 10}"
                                        onchange="updateCharacter('${character.id}', 'ac', parseInt(this.value) || 0)"
                                        class="editable-field stat-input"
                        >
                    </div>
                            </div>
                            <div class="header-stat">
                                <div class="ac-inputs">
                                    <span class="heart-icon">❤️</span>
                                    <input
                                        type="number"
                                        value="${character.hp || 10}"
                                        onchange="updateCharacter('${character.id}', 'hp', parseInt(this.value) || 0)"
                                        class="editable-field ac-input"
                                    >
                                    <span class="ac-separator">/</span>
                                    <input
                                        type="number"
                                        value="${character.acMax || character.hp || 10}"
                                        onchange="updateCharacter('${character.id}', 'acMax', parseInt(this.value) || 0)"
                                        class="editable-field ac-input"
                                    >
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Bottom Section: 6 Main Stats -->
                    <div class="header-bottom-section">
                        <div class="card-abilities">
                            <div class="ability-grid">
                                <div class="ability-item">
                                    <span class="ability-label">STR</span>
                                    <div class="stat-shield-wrapper">
                                        <input
                                            type="number"
                                            value="${character.strength}"
                                            onchange="updateCharacter('${character.id}', 'strength', parseInt(this.value) || 0)"
                                            class="editable-field ability-input"
                                            min="1"
                                            max="20"
                                        >
                                    </div>
                                </div>
                                <div class="ability-item">
                                    <span class="ability-label">DEX</span>
                                    <div class="stat-shield-wrapper">
                                        <input
                                            type="number"
                                            value="${character.dexterity}"
                                            onchange="updateCharacter('${character.id}', 'dexterity', parseInt(this.value) || 0)"
                                            class="editable-field ability-input"
                                            min="1"
                                            max="20"
                                        >
                                    </div>
                                </div>
                                <div class="ability-item">
                                    <span class="ability-label">CON</span>
                                    <div class="stat-shield-wrapper">
                                        <input
                                            type="number"
                                            value="${character.constitution}"
                                            onchange="updateCharacter('${character.id}', 'constitution', parseInt(this.value) || 0)"
                                            class="editable-field ability-input"
                                            min="1"
                                            max="20"
                                        >
                                    </div>
                                </div>
                                <div class="ability-item">
                                    <span class="ability-label">INT</span>
                                    <div class="stat-shield-wrapper">
                                        <input
                                            type="number"
                                            value="${character.intelligence}"
                                            onchange="updateCharacter('${character.id}', 'intelligence', parseInt(this.value) || 0)"
                                            class="editable-field ability-input"
                                            min="1"
                                            max="20"
                                        >
                                    </div>
                                </div>
                                <div class="ability-item">
                                    <span class="ability-label">WIS</span>
                                    <div class="stat-shield-wrapper">
                                        <input
                                            type="number"
                                            value="${character.wisdom}"
                                            onchange="updateCharacter('${character.id}', 'wisdom', parseInt(this.value) || 0)"
                                            class="editable-field ability-input"
                                            min="1"
                                            max="20"
                                        >
                                    </div>
                                </div>
                                <div class="ability-item">
                                    <span class="ability-label">CHA</span>
                                    <div class="stat-shield-wrapper">
                                        <input
                                            type="number"
                                            value="${character.charisma}"
                                            onchange="updateCharacter('${character.id}', 'charisma', parseInt(this.value) || 0)"
                                            class="editable-field ability-input"
                                            min="1"
                                            max="20"
                                        >
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="card-tabs">
                            <button class="tab-btn ${getActiveTabClass(character.id, 'stats')}" onclick="switchTab('${character.id}', 'stats')" data-tab="stats">
                                Home
                            </button>
                            <button class="tab-btn ${getActiveTabClass(character.id, 'newstats')}" onclick="switchTab('${character.id}', 'newstats')" data-tab="newstats">
                                Stats
                            </button>
                            <button class="tab-btn ${getActiveTabClass(character.id, 'abilities')}" onclick="switchTab('${character.id}', 'abilities')" data-tab="abilities">
                                Skills
                            </button>
                            ${!character.isEnemy ? `<button class="tab-btn ${getActiveTabClass(character.id, 'inventory')}" onclick="switchTab('${character.id}', 'inventory')" data-tab="inventory">
                                Bag
                            </button>` : ''}
                            ${!character.isEnemy ? `<button class="tab-btn ${getActiveTabClass(character.id, 'story')}" onclick="switchTab('${character.id}', 'story')" data-tab="story">
                                Story
                            </button>` : ''}
                        </div>
                    </div>
                </div>

                <div class="card-body">
                    <!-- Stats Tab Content -->
                    <div class="tab-content ${getActiveTabClass(character.id, 'stats')}" id="stats-content-${character.id}">

                        <div class="character-image-section">
                            <div class="character-image-placeholder ${character.photo ? 'has-photo' : ''}" onclick="triggerPhotoUpload('${character.id}')">
                                <div class="image-placeholder-content">
                                    <span class="image-placeholder-text">Character Image</span>
                                    <span class="image-placeholder-subtext">Click to upload</span>
                                </div>
                                ${character.photo ? `<img src="${character.photo}" alt="Character" class="character-photo" onerror="handleImageError(this)">` : ''}
                            </div>
                            <input type="file" id="photo-input-${character.id}" accept="image/*" style="display: none;" onchange="handlePhotoUpload(event, '${character.id}')">
                        </div>

                        <div class="character-info-section">
                            <div class="info-row">
                                <div class="info-group-inline">
                                    <label class="info-label-inline">Class:</label>
                                    <input
                                        type="text"
                                        value="${character.class}"
                                        onchange="updateCharacter('${character.id}', 'class', this.value)"
                                        class="editable-field card-class-inline"
                                    >
                                </div>
                                <div class="info-group-inline">
                                    <label class="info-label-inline">Level:</label>
                                    <input
                                        type="number"
                                        value="${character.level}"
                                        onchange="updateCharacter('${character.id}', 'level', parseInt(this.value) || 1)"
                                        class="editable-field level-input-inline"
                                        min="1"
                                        max="20"
                                    >
                                </div>
                                <div class="info-group-inline">
                                    <label class="info-label-inline">Race:</label>
                                    <input
                                        type="text"
                                        value="${character.race}"
                                        onchange="updateCharacter('${character.id}', 'race', this.value)"
                                        class="editable-field race-input-inline"
                                    >
                                </div>
                            </div>
                        </div>

                        <div class="bio-section">
                            <div class="bio-item">
                                <textarea value="${character.bio || ''}" onchange="updateCharacter('${character.id}', 'bio', this.value)" class="editable-field bio-textarea" placeholder="Add a short bio of your character, what abilities they have and what they are after">${character.bio || ''}</textarea>
                            </div>
                        </div>

                        <div class="active-effects-section">
                            <div class="active-effects-item">
                                <label class="active-effects-label">Active Conditions:</label>
                                <textarea value="${character.activeEffects || ''}" onchange="updateCharacter('${character.id}', 'activeEffects', this.value)" class="editable-field active-effects-textarea" placeholder="Enter active effects, buffs, debuffs, conditions...">${character.activeEffects || ''}</textarea>
                            </div>
                        </div>
                    </div>

                    <!-- Abilities Tab Content -->
                    <div class="tab-content ${getActiveTabClass(character.id, 'abilities')}" id="abilities-content-${character.id}">
                        <div class="abilities-section">
                            <div class="abilities-item">
                                <label class="abilities-label">Ability 1:</label>
                                <textarea value="${character.ability1 || ''}" onchange="updateCharacter('${character.id}', 'ability1', this.value)" class="editable-field abilities-textarea" placeholder="Enter ability description...">${character.ability1 || ''}</textarea>
                            </div>
                            <div class="abilities-item">
                                <label class="abilities-label">Ability 2:</label>
                                <textarea value="${character.ability2 || ''}" onchange="updateCharacter('${character.id}', 'ability2', this.value)" class="editable-field abilities-textarea" placeholder="Enter ability description...">${character.ability2 || ''}</textarea>
                            </div>
                            <div class="abilities-item">
                                <label class="abilities-label">Ability 3:</label>
                                <textarea value="${character.ability3 || ''}" onchange="updateCharacter('${character.id}', 'ability3', this.value)" class="editable-field abilities-textarea" placeholder="Enter ability description...">${character.ability3 || ''}</textarea>
                            </div>
                            <div class="abilities-item">
                                <label class="abilities-label">Ultimate Feature:</label>
                                <textarea value="${character.ultimate || ''}" onchange="updateCharacter('${character.id}', 'ultimate', this.value)" class="editable-field abilities-textarea" placeholder="Enter ultimate feature description...">${character.ultimate || ''}</textarea>
                            </div>
                        </div>
                    </div>

                    ${!character.isEnemy ? `<!-- Inventory Tab Content -->
                    <div class="tab-content ${getActiveTabClass(character.id, 'inventory')}" id="inventory-content-${character.id}">
                        <div class="inventory-section">
                            <div class="inventory-item">
                                <label class="inventory-label">Weapon:</label>
                                <input type="text" value="${character.weapon || ''}" onchange="updateCharacter('${character.id}', 'weapon', this.value)" class="editable-field inventory-input" placeholder="Enter weapon...">
                            </div>
                            <div class="inventory-item">
                                <label class="inventory-label">Armor:</label>
                                <input type="text" value="${character.armor || ''}" onchange="updateCharacter('${character.id}', 'armor', this.value)" class="editable-field inventory-input" placeholder="Enter armor...">
                            </div>
                            <div class="inventory-item">
                                <label class="inventory-label">Shield:</label>
                                <input type="text" value="${character.shield || ''}" onchange="updateCharacter('${character.id}', 'shield', this.value)" class="editable-field inventory-input" placeholder="Enter shield...">
                            </div>
                            <div class="inventory-item">
                                <label class="inventory-label">Items:</label>
                                <textarea value="${character.items || ''}" onchange="updateCharacter('${character.id}', 'items', this.value)" class="editable-field inventory-textarea" placeholder="Enter inventory items...">${character.items || ''}</textarea>
                            </div>
                        </div>
                    </div>` : ''}

                    ${!character.isEnemy ? `<!-- Story Tab Content -->
                    <div class="tab-content ${getActiveTabClass(character.id, 'story')}" id="story-content-${character.id}">
                        <div class="story-section">
                            <div class="story-item">
                                <label class="story-label">Background:</label>
                                <textarea value="${character.background || ''}" onchange="updateCharacter('${character.id}', 'background', this.value)" class="editable-field story-textarea" placeholder="Enter character background...">${character.background || ''}</textarea>
                            </div>
                            <div class="story-item">
                                <label class="story-label">Personality:</label>
                                <textarea value="${character.personality || ''}" onchange="updateCharacter('${character.id}', 'personality', this.value)" class="editable-field story-textarea" placeholder="Enter personality traits...">${character.personality || ''}</textarea>
                            </div>
                            <div class="story-item">
                                <label class="story-label">Goals:</label>
                                <textarea value="${character.goals || ''}" onchange="updateCharacter('${character.id}', 'goals', this.value)" class="editable-field story-textarea" placeholder="Enter character goals...">${character.goals || ''}</textarea>
                            </div>
                        </div>
                    </div>` : ''}

                    <!-- New Stats Tab Content -->
                    <div class="tab-content" id="newstats-content-${character.id}">
                        <!-- Content will be added here -->
                    </div>
                </div>
                
                <div class="card-footer">
                    <div class="footer-left">
                        <button class="death-toggle-btn ${character.isDead ? '' : 'alive'}" onclick="toggleDeath('${character.id}')">
                            ${character.isDead ? '💀 Dead' : '⚡ Alive'}
                        </button>
                    </div>
                    <div class="footer-center">
                        ${character.isEnemy ? `
                            <!-- Enemy Controls -->
                            <button class="attack-btn" onclick="showAttackModal('${character.id}')">
                                ⚔️ Attack
                            </button>
                            <button class="hide-toggle-btn ${character.isHidden ? 'hidden' : 'visible'}" onclick="toggleMonsterVisibility('${character.id}')">
                                ${character.isHidden ? '👁️ Show' : '🙈 Hide'}
                            </button>
                        ` : `
                            <!-- Player Death Saves -->
                            <div class="death-saves">
                                <span class="death-saves-label">Death Saves</span>
                                <div class="death-saves-bubbles">
                                    <div class="death-save-bubble ${(character.deathSaves || 0) >= 1 ? 'filled' : ''}" onclick="toggleDeathSave('${character.id}', 1)"></div>
                                    <div class="death-save-bubble ${(character.deathSaves || 0) >= 2 ? 'filled' : ''}" onclick="toggleDeathSave('${character.id}', 2)"></div>
                                    <div class="death-save-bubble ${(character.deathSaves || 0) >= 3 ? 'filled' : ''}" onclick="toggleDeathSave('${character.id}', 3)"></div>
                                </div>
                            </div>
                        `}
                    </div>
                    <div class="footer-right">
                        ${!character.isEnemy ? `
                            <button class="open-deck-btn" onclick="toggleDeck('${character.id}')" id="deck-btn-${character.id}">
                                📦 Deck
                            </button>
                        ` : ''}
                        <button class="remove-card-btn" onclick="removeCharacter('${character.id}')">
                            ✕
                        </button>
                    </div>
                </div>

            `;
            
            return card;
        }

        // Create item card HTML
        function createItemCard(item, characterId) {
            const itemCard = document.createElement('div');
            itemCard.className = 'item-card';
            itemCard.setAttribute('data-item-id', item.id);
            
            itemCard.innerHTML = `
                <div class="card-texture"></div>
                <div class="item-card-header">
                    <input type="text" 
                           class="item-card-name editable-field" 
                           value="${item.name || 'New Item'}"
                           onchange="updateItem('${item.id}', 'name', this.value)"
                           placeholder="Item Name">
                </div>
                <div class="item-card-body">
                    <textarea class="item-card-description editable-field"
                              onchange="updateItem('${item.id}', 'description', this.value)"
                              placeholder="Enter item description, effects, or lore...">${item.description || ''}</textarea>
                </div>
                <div class="item-card-footer">
                    <div class="item-card-type">Item</div>
                    <button class="delete-item-btn" onclick="deleteItem('${item.id}', '${characterId}', event)">
                        ✕
                    </button>
                </div>
            `;
            
            return itemCard;
        }

        // Photo upload functions
        function triggerPhotoUpload(characterId) {
            const fileInput = document.getElementById(`photo-input-${characterId}`);
            fileInput.click();
        }

        function handlePhotoUpload(event, characterId) {
            const file = event.target.files[0];
            if (!file) return;

            // Check file size (limit to 5MB)
            if (file.size > 5 * 1024 * 1024) {
                alert('Photo size must be less than 5MB');
                return;
            }

            // Check file type
            if (!file.type.startsWith('image/')) {
                alert('Please select a valid image file');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const base64Image = e.target.result;
                
                // Update character with photo data
                updateCharacter(characterId, 'photo', base64Image);
                
                // Update the UI immediately
                updatePhotoDisplay(characterId, base64Image);
            };
            reader.readAsDataURL(file);
        }

        function updatePhotoDisplay(characterId, photoData) {
            const placeholder = document.querySelector(`[data-character-id="${characterId}"] .character-image-placeholder`);
            if (!placeholder) return;

            // Remove existing photo
            const existingPhoto = placeholder.querySelector('.character-photo');
            if (existingPhoto) {
                existingPhoto.remove();
            }

            if (photoData) {
                // Add has-photo class
                placeholder.classList.add('has-photo');
                
                // Create and add new photo
                const img = document.createElement('img');
                img.src = photoData;
                img.alt = 'Character';
                img.className = 'character-photo';
                placeholder.appendChild(img);
            } else {
                // Remove has-photo class
                placeholder.classList.remove('has-photo');
            }
        }
    </script>
            <footer class="basic-footer">
            <div class="footer-content">
                <div class="footer-left">
                    <button class="dice-roller-btn" onclick="toggleDiceRoller()">
                        🎲 Roll Dice
                    </button>
                </div>
                <div class="footer-middle">
                    <div class="music-player">
                        <audio controls class="runescape-audio">
                            <source src="music/background-music.mp3" type="audio/mpeg">
                            Your browser does not support the audio element.
                        </audio>
                    </div>
                </div>
                <div class="footer-right">
                    <button class="message-board-btn" onclick="toggleMessageBoard()">
                        💬 Message Board
                    </button>
                </div>
            </div>
        </footer>

    <!-- Small Dice Roller Popup -->
    <div class="dice-roller-popup" id="diceRollerPopup">
        <div class="dice-roller-popup-content">
            <div class="dice-roller-popup-header">
                <h3>🎲 Dice Roller</h3>
                <button class="close-dice-popup-btn" onclick="toggleDiceRoller()">✕</button>
            </div>
            
            <div class="dice-roller-popup-body">
                <div class="dice-selection-popup">
                    <div class="dice-type-selector-popup">
                        <button class="dice-type-btn-popup active" data-dice="d4">d4</button>
                        <button class="dice-type-btn-popup" data-dice="d6">d6</button>
                        <button class="dice-type-btn-popup" data-dice="d8">d8</button>
                        <button class="dice-type-btn-popup" data-dice="d10">d10</button>
                        <button class="dice-type-btn-popup" data-dice="d12">d12</button>
                        <button class="dice-type-btn-popup" data-dice="d20">d20</button>
                        <button class="dice-type-btn-popup" data-dice="d100">d100</button>
                    </div>
                    
                    <div class="dice-controls-popup">
                        <div class="control-group">
                            <label>Qty:</label>
                            <div class="quantity-controls-popup">
                                <button class="control-btn-popup" onclick="changeQuantity(-1)">-</button>
                                <span id="diceQuantityPopup">1</span>
                                <button class="control-btn-popup" onclick="changeQuantity(1)">+</button>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label>Mod:</label>
                            <div class="modifier-controls-popup">
                                <button class="control-btn-popup" onclick="changeModifier(-1)">-</button>
                                <span id="diceModifierPopup">0</span>
                                <button class="control-btn-popup" onclick="changeModifier(1)">+</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="dice-tray-popup" id="diceTrayPopup">
                    <div class="dice-container-popup" id="diceContainerPopup">
                        <!-- Dice will be added here -->
                    </div>
                    <button class="roll-dice-btn-popup" onclick="rollDicePopup()" id="rollDiceBtnPopup">
                        🎲 ROLL
                    </button>
                </div>
                
                <div class="roll-result-popup" id="rollResultPopup">
                    <!-- Latest roll result will be shown here -->
                </div>
                
                <div class="roll-history-popup" id="rollHistoryPopup">
                    <h4>Roll History</h4>
                    <div class="history-list-popup" id="historyListPopup">
                        <!-- Roll history will be displayed here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Message Board Popup -->
    <div class="message-board-popup" id="messageBoardPopup">
        <div class="message-board-popup-content">
            <div class="message-board-popup-header">
                <h3>💬 Message Board</h3>
                <button class="close-message-board-btn" onclick="toggleMessageBoard()">✕</button>
            </div>
            
            <div class="message-board-popup-body">
                <div class="message-input-section">
                    <div class="character-selector">
                        <label>Character:</label>
                        <select id="messageCharacterSelect" class="character-select">
                            <option value="">Select Character...</option>
                        </select>
                    </div>
                    <div class="message-input-container">
                        <input type="text" id="messageInput" class="message-input" placeholder="Type your message..." maxlength="200">
                        <button class="send-message-btn" onclick="sendMessage()" id="sendMessageBtn">
                            Send
                        </button>
                    </div>
                </div>
                
                <div class="message-display" id="messageDisplay">
                    <div class="message-list" id="messageList">
                        <!-- Messages will be displayed here -->
                    </div>
                </div>
                
                <div class="message-tabs">
                    <button class="message-tab active" data-tab="all" onclick="switchMessageTab('all')">All</button>
                    <button class="message-tab" data-tab="ooc" onclick="switchMessageTab('ooc')">OOC</button>
                    <button class="message-tab" data-tab="ic" onclick="switchMessageTab('ic')">IC</button>
                    <button class="message-tab" data-tab="dm" onclick="switchMessageTab('dm')">DM</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Overlay Template (will be cloned and positioned on cards) -->
    <div id="deleteOverlayTemplate" class="delete-overlay" style="display: none;">
        <h3>Delete Character</h3>
        <p class="delete-message">Are you sure you want to delete this character?</p>
        <div class="delete-overlay-buttons">
            <button class="delete-confirm-btn" onclick="confirmDelete()">Delete</button>
            <button class="delete-cancel-btn" onclick="closeDeleteOverlay()">Cancel</button>
        </div>
    </div>



    <!-- Attack Overlay Template (will be cloned and positioned on cards) -->
    <div id="attackOverlayTemplate" class="attack-overlay" style="display: none;">
        <h3>Attack</h3>
        <p>Damage:</p>
        <input type="number" class="damage-input" min="0" placeholder="0">
        <div class="attack-overlay-buttons">
            <button class="attack-confirm-btn" onclick="confirmAttack()">Apply</button>
            <button class="attack-cancel-btn" onclick="closeAttackOverlay()">Cancel</button>
        </div>
    </div>

    <script>
        // Monster Browser Functionality
        let allMonsters = [];
        let filteredMonsters = [];
        let visibleMonsters = [];
        let currentStartIndex = 0;
        const MONSTERS_PER_BATCH = 20; // Load 20 monsters at a time for performance
        let isLoading = false;

        // Initialize monster browser when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadAllMonstersFromAPI();
        });

        // Load all monsters from D&D 5e API
        async function loadAllMonstersFromAPI() {
            try {
                const container = document.getElementById('monsterBrowserContent');
                container.innerHTML = '<div class="monster-loading">Loading monsters from D&D 5e API...</div>';

                const response = await fetch('https://www.dnd5eapi.co/api/2014/monsters');
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    allMonsters = data.results;
                    filteredMonsters = [...allMonsters];
                    console.log(`Loaded ${allMonsters.length} monsters from D&D 5e API`);
                    initializeMonsterBrowser();
                } else {
                    container.innerHTML = '<div class="monster-error">No monsters found in API</div>';
                }
            } catch (error) {
                console.error('Error loading monsters:', error);
                const container = document.getElementById('monsterBrowserContent');
                container.innerHTML = '<div class="monster-error">Error loading monsters. Please try again later.</div>';
            }
        }

        function initializeMonsterBrowser() {
            const container = document.getElementById('monsterBrowserContent');
            container.innerHTML = ''; // Clear loading message
            loadMonsterBatch(0, MONSTERS_PER_BATCH);
            setupInfiniteScroll();
        }

        function loadMonsterBatch(startIndex, count) {
            if (isLoading) return;
            isLoading = true;

            const container = document.getElementById('monsterBrowserContent');
            
            // Show loading skeletons
            for (let i = 0; i < Math.min(count, filteredMonsters.length - startIndex); i++) {
                const skeleton = document.createElement('div');
                skeleton.className = 'monster-skeleton';
                container.appendChild(skeleton);
            }

            // Load monsters with a small delay to show loading state
            setTimeout(() => {
                // Remove skeletons
                const skeletons = container.querySelectorAll('.monster-skeleton');
                skeletons.forEach(skeleton => skeleton.remove());

                // Add actual monster cards
                const endIndex = Math.min(startIndex + count, filteredMonsters.length);
                for (let i = startIndex; i < endIndex; i++) {
                    const monster = filteredMonsters[i];
                    const monsterCard = createMonsterMiniCard(monster);
                    container.appendChild(monsterCard);
                    visibleMonsters.push(monster);
                }

                currentStartIndex = endIndex;
                isLoading = false;
                updateNavigationButtons();
            }, 100); // Shorter delay since we're not hitting API
        }

        function createMonsterMiniCard(monster) {
            const card = document.createElement('div');
            card.className = 'monster-card-mini';
            card.dataset.monsterId = monster.index;
            
            // Use same image path as existing monster search
            const imageUrl = `monster-images/${monster.index}.png`;
            
            card.innerHTML = `
                <div class="monster-card-mini-image loading" style="background-image: url('${imageUrl}')"></div>
                <div class="monster-card-mini-content">
                    <div class="monster-card-mini-name">${monster.name}</div>
                    <button class="monster-card-mini-add" onclick="addMonsterToEnemyDeckFromBrowser('${monster.index}')">
                        ADD
                    </button>
                </div>
            `;

            // Handle image loading (same as existing system)
            const img = new Image();
            img.onload = () => {
                const imageDiv = card.querySelector('.monster-card-mini-image');
                imageDiv.classList.remove('loading');
            };
            img.onerror = () => {
                const imageDiv = card.querySelector('.monster-card-mini-image');
                imageDiv.classList.remove('loading');
                imageDiv.style.backgroundImage = 'url("monster-images/placeholder.png")';
            };
            img.src = imageUrl;

            return card;
        }

        function setupInfiniteScroll() {
            const scrollContainer = document.getElementById('monsterBrowserScroll');
            
            scrollContainer.addEventListener('scroll', () => {
                const { scrollLeft, scrollWidth, clientWidth } = scrollContainer;
                
                // Load more when scrolled near the end
                if (scrollLeft + clientWidth >= scrollWidth - 200) {
                    if (currentStartIndex < filteredMonsters.length) {
                        loadMonsterBatch(currentStartIndex, MONSTERS_PER_BATCH);
                    }
                }
            });
        }

        // Add monster to enemy deck using the same logic as existing selectMonster function
        async function addMonsterToEnemyDeckFromBrowser(monsterIndex) {
            try {
                // Use the same API call as the existing selectMonster function
                const response = await fetch(`https://www.dnd5eapi.co/api/2014/monsters/${monsterIndex}`);
                const monster = await response.json();
                
                // Create enemy from monster data (same as existing selectMonster function)
                const campaignPath = getCampaignPath();
                const timestamp = Date.now();
                
                // Store timestamp for animation (same as character system)
                newEnemyTimestamp = timestamp;
                
                // Build description from monster data
                let description = `CR ${monster.challenge_rating || '?'} ${monster.type || 'Unknown'}`;
                
                if (monster.size) description = `${monster.size} ${description}`;
                if (monster.alignment) description += ` (${monster.alignment})`;
                
                // Add key abilities/actions
                if (monster.special_abilities && monster.special_abilities.length > 0) {
                    description += '\\n\\nSpecial Abilities:\\n';
                    monster.special_abilities.slice(0, 3).forEach(ability => {
                        description += `• ${ability.name}: ${ability.desc}\\n`;
                    });
                }
                
                if (monster.actions && monster.actions.length > 0) {
                    description += '\\nActions:\\n';
                    monster.actions.slice(0, 3).forEach(action => {
                        description += `• ${action.name}: ${action.desc}\\n`;
                    });
                }
                
                // Use local custom monster image with fallback to placeholder
                const imageUrl = `monster-images/${monster.index}.png`;
                
                const newEnemy = {
                    name: monster.name,
                    hp: monster.hit_points || 1,
                    maxHp: monster.hit_points || 1,
                    ac: (monster.armor_class && monster.armor_class[0] ? monster.armor_class[0].value : null) || 10,
                    description: description,
                    isDead: false,
                    // Add monster image if available
                    imageUrl: imageUrl,
                    // Populate ability scores from monster data
                    strength: monster.strength || 10,
                    dexterity: monster.dexterity || 10,
                    constitution: monster.constitution || 10,
                    intelligence: monster.intelligence || 10,
                    wisdom: monster.wisdom || 10,
                    charisma: monster.charisma || 10,
                    // Map type to class and size+alignment to race
                    class: monster.type ? monster.type.charAt(0).toUpperCase() + monster.type.slice(1) : 'Beast',
                    race: `${monster.size || 'Medium'} ${monster.alignment || 'Neutral'}`,
                    monsterData: monster, // Store full monster data for reference
                    lastUpdated: timestamp
                };
                
                console.log(`Adding D&D monster ${monster.name} from browser to guild: ${getGuildId()}, campaign: ${currentCampaignId}`);
                
                // Add to Firebase
                database.ref(`${campaignPath}/enemies`).push(newEnemy);
                
            } catch (error) {
                console.error('Error loading monster:', error);
                showMonsterAddedFeedback('Error loading monster data. Please try again.');
            }
        }

        function showMonsterAddedFeedback(message) {
            // Only show error messages now - success is handled by the card animation
            if (message.toLowerCase().includes('error')) {
                // Create temporary feedback element for errors only
                const feedback = document.createElement('div');
                feedback.style.cssText = `
                    position: fixed;
                    top: 80px;
                    right: 20px;
                    background: linear-gradient(180deg, #dc2626 0%, #b91c1c 100%);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 6px;
                    font-weight: bold;
                    z-index: 10000;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                    transform: translateX(100%);
                    transition: transform 0.3s ease;
                `;
                feedback.textContent = message;
                
                document.body.appendChild(feedback);
                
                // Animate in
                setTimeout(() => feedback.style.transform = 'translateX(0)', 100);
                
                // Animate out and remove
                setTimeout(() => {
                    feedback.style.transform = 'translateX(100%)';
                    setTimeout(() => feedback.remove(), 300);
                }, 3000);
            }
        }

        function filterMonsters(searchTerm) {
            const term = searchTerm.toLowerCase().trim();
            
            if (!term) {
                filteredMonsters = [...allMonsters];
            } else {
                filteredMonsters = allMonsters.filter(monster => 
                    monster.name.toLowerCase().includes(term) ||
                    monster.index.toLowerCase().includes(term)
                );
            }
            
            resetMonsterBrowser();
        }

        function filterMonstersByType(type) {
            if (!type) {
                filteredMonsters = [...allMonsters];
            } else {
                // Filter by name patterns (same logic as before but more comprehensive)
                filteredMonsters = allMonsters.filter(monster => {
                    const name = monster.name.toLowerCase();
                    switch(type) {
                        case 'dragon':
                            return name.includes('dragon') || name.includes('drake') || name.includes('wyrmling');
                        case 'giant':
                            return name.includes('giant');
                        case 'elemental':
                            return name.includes('elemental') || name.includes('mephit');
                        case 'undead':
                            return name.includes('zombie') || name.includes('skeleton') || 
                                   name.includes('ghost') || name.includes('wraith') || 
                                   name.includes('lich') || name.includes('vampire') ||
                                   name.includes('mummy') || name.includes('wight') ||
                                   name.includes('specter') || name.includes('banshee');
                        case 'fiend':
                            return name.includes('devil') || name.includes('demon') || 
                                   name.includes('imp') || name.includes('succubus') ||
                                   name.includes('incubus') || name.includes('balor') ||
                                   name.includes('pit fiend') || name.includes('erinyes');
                        case 'beast':
                            return name.includes('wolf') || name.includes('bear') || 
                                   name.includes('eagle') || name.includes('shark') ||
                                   name.includes('tiger') || name.includes('lion') ||
                                   name.includes('bat') || name.includes('rat') ||
                                   name.includes('cat') || name.includes('dog') ||
                                   name.includes('horse') || name.includes('owl');
                        case 'humanoid':
                            return name.includes('human') || name.includes('elf') ||
                                   name.includes('dwarf') || name.includes('orc') ||
                                   name.includes('goblin') || name.includes('hobgoblin') ||
                                   name.includes('gnoll') || name.includes('kobold') ||
                                   name.includes('bandit') || name.includes('guard') ||
                                   name.includes('noble') || name.includes('commoner');
                        case 'monstrosity':
                            return name.includes('owlbear') || name.includes('bulette') ||
                                   name.includes('manticore') || name.includes('chimera') ||
                                   name.includes('griffon') || name.includes('hippogriff');
                        case 'fey':
                            return name.includes('dryad') || name.includes('sprite') ||
                                   name.includes('pixie') || name.includes('satyr');
                        case 'celestial':
                            return name.includes('angel') || name.includes('deva') ||
                                   name.includes('solar') || name.includes('planetar');
                        default:
                            return true;
                    }
                });
            }
            
            resetMonsterBrowser();
        }

        function resetMonsterBrowser() {
            const container = document.getElementById('monsterBrowserContent');
            container.innerHTML = '';
            visibleMonsters = [];
            currentStartIndex = 0;
            loadMonsterBatch(0, MONSTERS_PER_BATCH);
        }

        function scrollMonsterBrowser(direction) {
            const scrollContainer = document.getElementById('monsterBrowserScroll');
            const scrollAmount = 384; // Scroll by ~2 cards (updated for larger cards: 180px + 12px gap = 192px per card)
            
            scrollContainer.scrollBy({
                left: direction * scrollAmount,
                behavior: 'smooth'
            });
        }

        function updateNavigationButtons() {
            const scrollContainer = document.getElementById('monsterBrowserScroll');
            const leftBtn = document.getElementById('monsterNavLeft');
            const rightBtn = document.getElementById('monsterNavRight');
            
            if (scrollContainer && leftBtn && rightBtn) {
                leftBtn.disabled = scrollContainer.scrollLeft <= 0;
                rightBtn.disabled = scrollContainer.scrollLeft + scrollContainer.clientWidth >= scrollContainer.scrollWidth;
            }
        }

        // Update navigation buttons on scroll
        document.addEventListener('DOMContentLoaded', function() {
            const scrollContainer = document.getElementById('monsterBrowserScroll');
            if (scrollContainer) {
                scrollContainer.addEventListener('scroll', updateNavigationButtons);
            }
        });

        // Spell Library Functionality
        let allSpells = [];
        let filteredSpells = [];
        let currentCharacterForSpells = null;


        // Load all spells from D&D 5e API (simplified approach like monsters)
        async function loadAllSpellsFromAPI() {
            try {
                const container = document.getElementById('spellBrowserContent');
                if (!container) return;
                
                container.innerHTML = '<div class="spell-loading">Loading spells from D&D 5e API...</div>';

                const response = await fetch('https://www.dnd5eapi.co/api/2014/spells');
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    allSpells = data.results;
                    filteredSpells = [...allSpells];
                    console.log(`Loaded ${allSpells.length} spells from D&D 5e API`);
                    
                    // Render spell library immediately with basic info
                    renderSpellLibrary();
                } else {
                    container.innerHTML = '<div class="spell-error">No spells found in API</div>';
                }
            } catch (error) {
                console.error('Error loading spells:', error);
                const container = document.getElementById('spellBrowserContent');
                if (container) {
                    container.innerHTML = '<div class="spell-error">Error loading spells. Please try again later.</div>';
                }
            }
        }

        // Load basic spell details (school, level) for filtering - ATOMIC operation with rate limiting
        async function loadBasicSpellDetails() {
            const spellsNeedingDetails = allSpells.filter(spell => !spell.school || spell.school === 'Loading...');
            if (spellsNeedingDetails.length === 0) return;
            
            console.log(`Loading basic details for ${spellsNeedingDetails.length} spells...`);
            
            try {
                // Create a map to store the loaded data WITHOUT modifying original objects yet
                const spellDataMap = new Map();
                let successCount = 0;
                let errorCount = 0;
                
                // Process spells in smaller batches to avoid rate limiting
                const batchSize = 10;
                const batches = [];
                for (let i = 0; i < spellsNeedingDetails.length; i += batchSize) {
                    batches.push(spellsNeedingDetails.slice(i, i + batchSize));
                }
                
                console.log(`Processing ${batches.length} batches of ${batchSize} spells each...`);
                
                for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                    const batch = batches[batchIndex];
                    console.log(`Processing batch ${batchIndex + 1}/${batches.length}...`);
                    
                    const promises = batch.map(async (spell) => {
                        try {
                            const response = await fetch(`https://www.dnd5eapi.co${spell.url}`);
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            const detailedSpell = await response.json();
                            
                            // Store the data in our map instead of modifying the spell directly
                            spellDataMap.set(spell.index, {
                                level: detailedSpell.level,
                                school: detailedSpell.school ? detailedSpell.school.name : 'Unknown',
                                classes: detailedSpell.classes || []
                            });
                            
                            successCount++;
                            return spell;
                        } catch (error) {
                            console.error(`Error loading basic details for spell ${spell.name}:`, error.message);
                            // Set default values for failed spells
                            spellDataMap.set(spell.index, {
                                level: 0,
                                school: 'Unknown',
                                classes: []
                            });
                            errorCount++;
                            return spell;
                        }
                    });
                    
                    // Wait for this batch to complete
                    await Promise.all(promises);
                    
                    // Add a small delay between batches to be nice to the API
                    if (batchIndex < batches.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                console.log(`Batch processing complete: ${successCount} success, ${errorCount} errors`);
                
                // Now update all spells ATOMICALLY - all at once
                spellsNeedingDetails.forEach(spell => {
                    const data = spellDataMap.get(spell.index);
                    if (data) {
                        spell.level = data.level;
                        spell.school = data.school;
                        spell.classes = data.classes;
                    }
                });
                
                console.log('Basic spell details loaded successfully - all spells now have consistent data');
                
                // Debug: Count necromancy spells after loading
                const necromancySpells = allSpells.filter(spell => spell.school && spell.school.toLowerCase() === 'necromancy');
                console.log(`Total necromancy spells in dataset: ${necromancySpells.length}`);
            } catch (error) {
                console.error('Error loading basic spell details:', error);
            }
        }

        // Load detailed spell information on-demand
        async function loadSpellDetails(spell) {
            try {
                const response = await fetch(`https://www.dnd5eapi.co${spell.url}`);
                const details = await response.json();
                
                return {
                    ...spell,
                    level: details.level,
                    school: details.school ? details.school.name : 'Unknown',
                    description: details.desc ? details.desc[0] : 'No description available',
                    classes: details.classes || [],
                    components: details.components || [],
                    range: details.range || 'Unknown',
                    duration: details.duration || 'Unknown',
                    casting_time: details.casting_time || 'Unknown'
                };
            } catch (error) {
                console.error(`Error loading spell details for ${spell.name}:`, error);
                return {
                    ...spell,
                    level: 'Unknown',
                    school: 'Unknown',
                    description: 'Error loading spell details',
                    classes: [],
                    components: [],
                    range: 'Unknown',
                    duration: 'Unknown',
                    casting_time: 'Unknown'
                };
            }
        }

        // Render spell library cards (with basic info, details loaded on-demand)
        function renderSpellLibrary() {
            const container = document.getElementById('spellBrowserContent');
            if (!container) return;
            
            container.innerHTML = '';
            
            filteredSpells.forEach((spell, index) => {
                const card = document.createElement('div');
                card.className = 'spell-library-card';
                
                // Use available data or show loading placeholders
                const levelText = spell.level !== undefined 
                    ? (spell.level === 0 ? 'Cantrip' : `${spell.level}${getOrdinalSuffix(spell.level)} Level`)
                    : 'Loading...';
                
                // Add image if available
                const spellImagePath = getSpellImagePath(spell.name);
                const imageSection = spellImagePath ? `
                    <div class="spell-library-image-section">
                        <img src="${spellImagePath}" alt="${spell.name}" class="spell-library-image" 
                             onerror="this.parentElement.style.display='none'">
                    </div>
                ` : '';
                
                card.innerHTML = `
                    ${imageSection}
                    <div class="spell-library-content">
                        <div class="spell-library-name">${spell.name}</div>
                        <div class="spell-library-level">${levelText}</div>
                        <div class="spell-library-school">${spell.school || 'Loading...'}</div>
                        <button class="spell-library-add-btn" onclick="addSpellToCharacterByIndex(event, ${index})">+ Add Spell</button>
                    </div>
                `;
                
                container.appendChild(card);
            });
        }

        // Helper function to add spell by index (loads details first)
        async function addSpellToCharacterByIndex(event, index) {
            if (event) event.stopPropagation();
            const spell = filteredSpells[index];
            if (spell) {
                // Show loading state on button
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'Loading...';
                button.disabled = true;
                
                try {
                    // Load detailed spell information
                    const detailedSpell = await loadSpellDetails(spell);
                    
                    // Add the spell with details
                    addSpellToCharacter(event, detailedSpell);
                    
                    // Restore button after successful addition
                    button.textContent = originalText;
                    button.disabled = false;
                } catch (error) {
                    console.error('Error loading spell details:', error);
                    button.textContent = 'Error!';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.disabled = false;
                    }, 2000);
                }
            }
        }

        // Add spell to character's spell list (using same pattern as addNewSpellToDeck)
        function addSpellToCharacter(event, spell) {
            if (event) event.stopPropagation(); // Prevent card click if button is clicked
            if (!currentCharacterForSpells) return;
            
            // Create new spell for character (using same structure as addNewSpellToDeck)
            const newSpell = {
                id: Date.now().toString(),
                name: spell.name,
                level: spell.level,
                school: spell.school.toLowerCase(),
                description: spell.description,
                characterId: currentCharacterForSpells,
                createdAt: Date.now()
            };
            
            // Initialize spells object if it doesn't exist (same as addNewSpellToDeck)
            if (!characterSpells) {
                characterSpells = {};
            }
            if (!characterSpells[currentCharacterForSpells]) {
                characterSpells[currentCharacterForSpells] = {};
            }
            
            characterSpells[currentCharacterForSpells][newSpell.id] = newSpell;
            
            // Save to Firebase (same pattern as addNewSpellToDeck)
            const campaignPath = getCampaignPath();
            database.ref(`${campaignPath}/characters/${currentCharacterForSpells}/spells/${newSpell.id}`).set(newSpell);
            
            // Add to the deck popup (same pattern as addNewSpellToDeck)
            const spellsScrollElement = document.getElementById('deck-spells-scroll');
            if (spellsScrollElement) {
                const spellCard = createSpellCard(newSpell, currentCharacterForSpells);
                
                // Add animation class for the new spell card
                spellCard.classList.add('spell-card-new');
                
                // Insert before the "Add Spell" button
                const addButton = spellsScrollElement.querySelector('.deck-add-spell');
                if (addButton) {
                    spellsScrollElement.insertBefore(spellCard, addButton);
                    
                    // Remove animation class after animation completes
                    setTimeout(() => {
                        spellCard.classList.remove('spell-card-new');
                    }, 1200);
                } else {
                    spellsScrollElement.appendChild(spellCard);
                    
                    // Remove animation class after animation completes
                    setTimeout(() => {
                        spellCard.classList.remove('spell-card-new');
                    }, 1200);
                }
            }
            

        }

        // Filter functions
        function filterSpells(searchTerm) {
            filteredSpells = [...allSpells];
            
            if (searchTerm.trim()) {
                filteredSpells = allSpells.filter(spell =>
                    spell.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    (spell.description && spell.description.toLowerCase().includes(searchTerm.toLowerCase()))
                );
            }
            
            applyAllSpellFilters();
            renderSpellLibrary();
        }

        async function filterSpellsByLevel(level) {
            // If filtering by level and spells don't have level data, load it
            if (level !== '' && allSpells.some(spell => spell.level === undefined)) {
                const container = document.getElementById('spellBrowserContent');
                container.innerHTML = '<div class="spell-loading"><div class="spell-loading-spinner"></div></div>';
                
                await loadBasicSpellDetails();
                
                // After loading, apply the filter and render
                applyAllSpellFilters();
                renderSpellLibrary();
                return;
            }
            applyAllSpellFilters();
            renderSpellLibrary();
        }

        async function filterSpellsBySchool(school) {
            // If we need school data and it's not loaded yet, load it ONCE
            if (school !== '' && allSpells.some(spell => !spell.school || spell.school === 'Loading...')) {
                const container = document.getElementById('spellBrowserContent');
                container.innerHTML = '<div class="spell-loading"><div class="spell-loading-spinner"></div></div>';
                
                // Wait for all data to be loaded before filtering
                await loadBasicSpellDetails();
                console.log('School data loaded, now filtering...');
            }
            
            // Now apply the filter to the complete, stable dataset
            applyAllSpellFilters();
            renderSpellLibrary();
        }



        function applyAllSpellFilters() {
            let filtered = [...allSpells];
            console.log(`Starting with ${filtered.length} spells`);
            
            // Apply search filter
            const searchTerm = document.getElementById('spellSearchInput')?.value || '';
            if (searchTerm.trim()) {
                filtered = filtered.filter(spell =>
                    spell.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    (spell.description && spell.description.toLowerCase().includes(searchTerm.toLowerCase()))
                );
                console.log(`After search filter: ${filtered.length} spells`);
            }
            
            // Apply level filter
            const levelFilter = document.getElementById('spellLevelFilter')?.value || '';
            if (levelFilter !== '') {
                filtered = filtered.filter(spell => spell.level === parseInt(levelFilter));
                console.log(`After level filter: ${filtered.length} spells`);
            }
            
            // Apply school filter
            const schoolFilter = document.getElementById('spellSchoolFilter')?.value || '';
            if (schoolFilter !== '') {
                const beforeSchoolFilter = filtered.length;
                const spellsWithSchoolData = filtered.filter(spell => spell.school).length;
                console.log(`Before school filter: ${beforeSchoolFilter} spells, ${spellsWithSchoolData} have school data`);
                
                filtered = filtered.filter(spell => {
                    return spell.school && spell.school.toLowerCase() === schoolFilter.toLowerCase();
                });
                console.log(`After school filter (${schoolFilter}): ${filtered.length} spells`);
                
                // Debug: List the actual spells found for necromancy
                if (schoolFilter.toLowerCase() === 'necromancy') {
                    console.log('Necromancy spells found:');
                    filtered.forEach(spell => console.log(`- ${spell.name} (school: ${spell.school})`));
                }
            }
            
            filteredSpells = filtered;
            console.log(`Final filtered spells: ${filteredSpells.length}`);
        }

        function getOrdinalSuffix(num) {
            const j = num % 10;
            const k = num % 100;
            if (j == 1 && k != 11) return "st";
            if (j == 2 && k != 12) return "nd";
            if (j == 3 && k != 13) return "rd";
            return "th";
        }

        // Initialize spell library when deck opens
        function initializeSpellLibrary(characterId) {
            currentCharacterForSpells = characterId;
            if (allSpells.length === 0) {
                loadAllSpellsFromAPI();
            } else {
                applyAllSpellFilters();
                renderSpellLibrary();
            }
        }
    </script>

</body>
</html> 
</html> 